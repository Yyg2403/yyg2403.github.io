[{"id":"51a66574dd41ddfb8a91132cd0319af4","title":"常见面试100题","content":"Java基础面试题[TOC]\n1、JDK 和 JRE 有什么区别？\n\n\n\n\n\n\n\n\n\nJVM : java虚拟机，是一个虚拟的中间平台，只负责将编译后的字节码文件转换成当前计算机能理解并执行的指令，特点：**跨平台、一次编译到处使用** 。\nJRE : java运行环境，包含除了JVM之外运行java程序所必须的运行时环境。\nJDK ：java开发工具包， 除了包含JRE以外，还包含了开发java程序所必须的命令工具。\n\n\n2、 == 和 equals 的区别是什么?\n\n\n\n\n\n\n\n\n\n== ：比较变量的值是否相等，可以比较基本类型变量的值或者引用变量的值，引用变量的值是地址值，比较引用变量时候就是比较这个地址值是否相等。\neuquls： 在Object类型上定义， 被全部Java类继承的方法，用于比较两个对象是否相等，其默认的实现采用了==比较两个引用值是否一样。可以在子类中重写，重写为比较两个对象的属性是否相等。Java的API，比如String重写了这个方法，比较两个字符串对象内容是否一样。\nJava 7 开始提供了工具方法Objects.equals用于实现equals方法。\n\n3、两个对象的 hashCode()相同，则 equals()也一定为 true，对吗?\n\n\n\n\n\n\n\n\n不对，两个对象的hashCode相同，equals不一定相同；\nString str1 &#x3D; &quot;通话&quot;;\nString str2 &#x3D; &quot;重地&quot;;\nSystem.out.println(String.format(&quot;str1：%d | str2：%d&quot;,  str1.hashCode(),str2.hashCode()));\nSystem.out.println(str1.equals(str2));\n\n执行结果为：\nstr1：1179395 | str2：1179395\nfalse\n\n很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为**在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等**。\n4、面向对象的特征有哪些方面？\n\n\n\n\n\n\n\n\n\n封装：将对象的状态信息尽可能的隐藏在对象内部，只保留有限的接口和方法与外界进行交互，从而避免了外界对对象内部属性的破坏。Java中使用访问控制符来保护对类、变量、方法和构造方法的访问。Java支持4种不同的访问权限。\n继承：使得低层级的类可以延用高层级类的特征和方法。类的继承是单一继承的。子类拥有父类所有的成员变量，但对于父类private的成员变量却没有访问权限，这保障了父类的封装性。\n多态：同一个行为具有多个不同表现形式或形态的能力。多态性是对象多种表现形式的体现。\n\n5、String 是最基本的数据类型吗？\n\n\n\n\n\n\n\n\nString 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、double、long，而String 属于对象。\n6、float f=3.4;是否正确？\n\n\n\n\n\n\n\n\n不正确，小数3.4默认情况下是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;\n7、short s1 = 1; s1 = s1 + 1;有错吗? short s1 = 1; s1 += 1;有错吗？\n\n\n\n\n\n\n\n\n\n对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。\n而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。\n\n8、int和Integer有什么区别？\n\n\n\n\n\n\n\n\nint 是基本数据类型，Integer 是int类型的包装类型，能够将这些基本数据类型当成对象操作。\n从java5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。\n特别注意：如果整型字面量的值在**-128到127之间，那么不会new新的Integer对象**，而是直接引用常量池中的Integer对象\n9、&amp;和&amp;&amp;的区别？\n\n\n\n\n\n\n\n\n相同点：&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and）。\n不同点：\n（1）&amp;&amp;具有短路的功能，而&amp;不具备短路功能。\n（2）当&amp;运算符两边的表达式的结果都为true时，整个运算结果才为true。而&amp;&amp;运算符第一个表达式为false时，则结果为false，不再计算第二个表达式。\n（3）&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位，例如：0x31 &amp; 0x0f的结果为0x01。\n10、四舍五入：Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？\n\n\n\n\n\n\n\n\nMath.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。\n11、switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？\n\n\n\n\n\n\n\n\nSwitch可以作用在byte、short、char、int、枚举类型、String。无法作用到long类型中。\n在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。\n12、用最有效率的方法计算2乘以8？\n\n\n\n\n\n\n\n\n 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。\n13、数组有没有length()方法？String有没有length()方法？\n\n\n\n\n\n\n\n\njava中数组是没有length()方法的，只有length属性，数组array.length返回的是该数组的长度。字符串String是有length()方法的，str.length()返回的是该字符串的长度。\n14、在Java中，如何跳出当前的多重嵌套循环？\n\n\n\n\n\n\n\n\n\n使用标记：break。不推荐使用标记,因为它容易破坏代码的执行顺序。\n里层循环体控制：使外层的循环条件表达式的结果可以受到里层循环体代码的控制。\n\n15、构造器（constructor）是否可被重写（override）？\n\n\n\n\n\n\n\n\n重写是发生在子类与父类中，方法名、参数列表、返回值、访问修饰符和异常都相同。首先，构造器不能被继承，因为每个类名都不相同，而构造器的名称与类名相同，这肯定不能算是继承，所以，既然构造器不能被继承，因此不能被重写，但可以被重载。\n16、是否可以继承String类？\n\n\n\n\n\n\n\n\n不可以继承，String类是被final修饰的类；对String类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。\n17、java 中操作字符串都有哪些类？它们之间有什么区别？\n\n\n\n\n\n\n\n\n**String 、 StringBuffer 、StringBuilder**。\nString 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。\nStringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。\n18、重载（Overload）和重写（Override）有什么区别？\n\n\n\n\n\n\n\n\n重载：首先是位于一个类之中或者其子类中，具有相同的方法名，但是方法的参数不同，返回值类型可以相同也可以不同。\n（1）方法名必须相同\n（2）方法的参数列表一定不一样。\n（3）访问修饰符和返回值类型可以相同也可以不同。\n小结：重载就是对于不同的情况写不同的方法。 比如，同一个类中，写不同的构造函数用于初始化不同的参数。\n重写：一般都是表示子类和父类之间的关系，重写的特征：(**两同两小一大**原则)\n（1）方法名必须相同、参数列表必须相同。\n（2）派生类方法的返回值类型小于或等于超类方法返回值、派生类抛出异常小于或等于超类方法的异常。\n（3）派生类方法的访问权限大于或等于超类方法。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。\n（4）子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。\n（5）构造方法不能被重写，\n小结：就是具体的实现类对于父类的该方法实现不满意，需要自己在写一个满足于自己要求的方法。\n19、描述一下JVM加载class文件的原理机制？\n\n\n\n\n\n\n\n\n\nJava中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。\n\n类装载方式，有两种 ：1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，2.显式装载， 通过class.forname()等方法，显式加载需要的类\n\nJava类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。\n\nJava的类加载器有三个，对应Java的三种类:\n\nBootstrap Loader ：启动类加载器，是虚拟机自身的一部分。负责将存放在/ lib目录中的类库加载到虚拟机中。其无法被Java程序直接引用。 负责加载系统类 (指的是内置类，像是String，对应于C#中的System类和C/C++标准库中的类)ExtClassLoader ： 拓展类加载器，负责加载扩展类(就是继承类和实现类)AppClassLoader ：应用类加载器，负责加载用户类路径（ClassPath）上所指定的类库(程序员自定义的类)JVM中类的加载是由类加载器（Cl assLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。\n\n由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。\n\n类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。\n\n当类被加载后就进入连接阶段，这一阶段包括：\n\n验证：为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。\n\n准备：为静态变量分配内存并设置默认的初始值。解析：将符号引用替换为直接引用。最后JVM对类进行初始化，包括：  \n\n如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；如果类中存在初始化语句，就依次执行这些初始化语句。\n\n从Java 2（JDK 1.2）开始，类加载过程采取了双亲委派模型（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是启动类加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。\n\n双亲委派模型：要求除了顶层的启动类加载器外，其余加载器都应当有自己的父类加载器。类加载器之间的父子关系，一般不会以继承的关系来实现，而是通过组合关系复用父加载器的代码。\n\n双亲委派机制工作过程：\n\n如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。\n\n每个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，\n\n只有到父加载器反馈自己无法完成这个加载请求（它的搜索范围没有找到所需的类）时，子加载器才会尝试自己去加载。\n\n\n\n为什么要使用双亲委派机制：Java类随着它的类加载器一起具备了一种带优先级的层次关系。\n\n如果使用委托机制，会递归的向父类查找，也就是首选用Bootstrap尝试加载，如果找不到再向下。这里的System就能在Bootstrap中找到然后加载，如果此时类B也要加载System，也从Bootstrap开始，此时Bootstrap发现已经加载过了System那么直接返回内存中的System即可而不需要重新加载，这样内存中就只有一份System的字节码了。\n\n能不能自己写个类叫java.lang.System？答案：通常不可以，但可以采取另类方法达到这个需求。解释：为了不让我们写System类，类加载采用委托机制，这样可以保证父类加载器优先，父类加载器能找到的类，子加载器就没有机会加载。而System类是Bootstrap加载器加载的，就算自己重写，也总是使用Java系统提供的System，自己写的System类根本没有机会得到加载。\n\n但是，我们可以自己定义一个类加载器来达到这个目的，为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。\n\n\n20、char 型变量中能不能存贮一个中文汉字，为什么？\n\n\n\n\n\n\n\n\nchar类型是用来储存Unicode编码字符的，Unicode编码字符集中包含了汉字，所以可以存储汉字，但是部分特殊的中文字符并没有包含在Unicode编码字符集中，特殊字符就不能存。\nchar表示的范围是0–65535。\n21、抽象类（abstract class）和接口（interface）有什么异同？\n\n\n\n\n\n\n\n\n接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。\n相同点：    \n\n都不能被实例化\n可以将抽象类和接口类型作为引用类型\n一个类如果实现接口或继承抽象类，必须实现全部抽象方法，否则仍然是个抽象类。\n\n不同点：    \n\n接口只有方法定义，没有具体的实现，实现接口的类要实现接口的所有方法；抽象类可以有定义与实现。\n接口与类是实现关系，并且类可以多实现；抽象类与类是继承关系，只能被一个类继承。\n接口中成员全为public abstract抽象方法 ; 抽象类中可以有抽象方法，也可以没有，抽象方法需加abstract。\n接口中无静态方法，抽象类中可以有。\n接口中不能定义构造器，抽象类中可以。\n\n22、普通类和抽象类有哪些区别？\n\n\n\n\n\n\n\n\n\n普通类不能包含抽象方法，抽象类可以包含抽象方法。\n抽象类不能直接实例化，普通类可以直接实例化。\n\n23、抽象类必须要有抽象方法吗？\n\n\n\n\n\n\n\n\n不需要，抽象类不一定非要有抽象方法。\n24、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？\n\n\n\n\n\n\n\n\nStatic Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化\n25、Java 中会存在内存泄漏吗，请简单描述。\n\n\n\n\n\n\n\n\n由于java的JVM引入了垃圾回收机制，垃圾回收器会自动回收不再使用的对象，JVM是使用引用计数法和可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题（让JVM误以为此对象还在引用中，无法回收，造成内存泄漏）。\n1、静态集合类，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。\n2、各种连接，如数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。\n3、变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。\n4、内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。\n5、改变哈希值，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。\n6、过期引用，如果栈先增长，再收缩，那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些对象，他们也不会回收，因为栈中仍然保存这对象的引用，俗称过期引用，这个内存泄露很隐蔽。\n7、缓存泄漏，内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘，对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。\n8、监听器和回调，内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。需要确保回调立即被当作垃圾回收的最佳方法是只保存他的弱引用，例如将他们保存成为WeakHashMap中的键。\n26、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？\n\n\n\n\n\n\n\n\n都不能。\n\n抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。\n本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。\nsynchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。\n\n27、静态变量和实例变量的区别。\n\n\n\n\n\n\n\n\n静态变量：也叫做类变量，独立于方法之外的变量，有static修饰。\n实例变量：同样独立也是独立于方法之外的变量，但没有static修饰。\npublic class StaticTest &#123;\n private static int staticInt &#x3D; 2;&#x2F;&#x2F;静态变量\n private int random &#x3D; 2;&#x2F;&#x2F;实例变量\n\n public StaticTest() &#123;\n     staticInt++;\n     random++;\n     System.out.println(&quot;staticInt &#x3D; &quot;+staticInt+&quot;  random &#x3D; &quot;+random);\n &#125;\n\n public static void main(String[] args) &#123;\n     StaticTest test &#x3D; new StaticTest();\n     StaticTest test2 &#x3D; new StaticTest();\n &#125;\n&#125;\n\nstaticInt &#x3D; 3  random &#x3D; 3\nstaticInt &#x3D; 4  random &#x3D; 3\n\n**实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。**结合上述给出的例子。每创建一个实例对象，就会分配一个random，实例对象之间的random是互不影响的，所以就可以解释为什么输出的两个random值是相同的了。\n**静态变量不属于某个实例对象，而是属于整个类。只要程序加载了类的字节码，不用创建任何实例对象，静态变量就回被分配空间，静态变量就可以被使用了。**结合上述给出的例子，无论创建多少个实例对象，永远都只分配一个staticInt 变量，并且每创建一个实例对象,staticInt就会加一。\n总之，实例变量必须创建对象后，才可以通过这个对象来使用；静态变量则可以直接使用类名来引用（如果实例对象存在，也可以通过实例对象来引用）。\n其实，这也可以解释，为什么static修饰的方法不用在实例对象创建后，可以调用。而没有static修饰的方法必须要与对象关联在一起，必须创建一个对象后，才可以在该对象上进行方法调用。\n28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？\n\n\n\n\n\n\n\n\n不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。\n29、如何实现对象克隆？\n\n\n\n\n\n\n\n\n有两种方式：1). 实现Cloneable接口并重写Object类中的clone()方法；2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。\n30、GC是什么？为什么要有GC？\n\n\n\n\n\n\n\n\nGC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。\n要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。\n垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。\n垃圾回收主要关注 Java 堆\nJava 内存运行时区域中的程序计数器、虚拟机栈、本地方法栈随线程而生灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由 JIT 编译器进行一些优化），因此这几个区域的内存分配和回收都具备确定性，不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。\n而 Java 堆不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。\n判断哪些对象需要被回收\n有以下两种方法：\n引用计数法给对象添加一引用计数器，被引用一次计数器值就加 1；当引用失效时，计数器值就减 1；计数器为 0 时，对象就是不可能再被使用的，简单高效，缺点是无法解决对象之间相互循环引用的问题。\n可达性分析算法通过一系列的称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。此算法解决了上述循环引用的问题。\n在Java语言中，可作为 GC Roots 的对象包括下面几种：\n\na. 虚拟机栈（栈帧中的本地变量表）中引用的对象。\n\nb. 方法区中类静态属性引用的对象。\n\nc. 方法区中常量引用的对象。\n\nd. 本地方法栈中 JNI（Native方法）引用的对象\n\n\n作为 GC Roots 的节点主要在全局性的引用与执行上下文中。要明确的是，tracing gc必须以当前存活的对象集为 Roots，因此必须选取确定存活的引用类型对象。\nGC 管理的区域是 Java 堆，虚拟机栈、方法区和本地方法栈不被 GC 所管理，因此选用这些区域内引用的对象作为 GC Roots，是不会被 GC 所回收的。其中虚拟机栈和本地方法栈都是线程私有的内存区域，只要线程没有终止，就能确保它们中引用的对象的存活。而方法区中类静态属性引用的对象是显然存活的。常量引用的对象在当前可能存活，因此，也可能是 GC roots 的一部分。\n可达性分析算法不可达的对象将暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：\n如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，直接进行第二次标记。如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，因为如果一个对象在 finalize() 方法中执行缓慢，将很可能会一直阻塞 F-Queue 队列，甚至导致整个内存回收系统崩溃。\n值得注意的是，使用 finalize() 方法来“拯救”对象是不值得提倡的，它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。finalize() 能做的工作，使用 try-finally 或者其它方法都更适合、及时。\n31、String s = new String(“xyz”);创建了几个字符串对象？\n\n\n\n\n\n\n\n\n两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。\n32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？\n\n\n\n\n\n\n\n\n接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。\n33、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？\n\n\n\n\n\n\n\n\n可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。\n34、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？\n\n\n\n\n\n\n\n\n可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。\n35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？\n\n\n\n\n\n\n\n\n一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。\n完全可以。如果不是静态内部类，那没有什么限制！如果你把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员\n36、Java 中的final关键字有哪些用法？\n\n\n\n\n\n\n\n\n(1)修饰类：表示该类不能被继承；\n(2)修饰方法：表示方法不能被重写；\n(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。\n37、指出下面程序的运行结果。class A &#123;\n\n    static &#123;\n        System.out.print(&quot;1&quot;);\n    &#125;\n\n    public A() &#123;\n        System.out.print(&quot;2&quot;);\n    &#125;\n&#125;\n\nclass B extends A&#123;\n\n    static &#123;\n        System.out.print(&quot;a&quot;);\n    &#125;\n\n    public B() &#123;\n        System.out.print(&quot;b&quot;);\n    &#125;\n&#125;\n\npublic class Hello &#123;\n\n    public static void main(String[] args) &#123;\n        A ab &#x3D; new B();\n        ab &#x3D; new B();\n    &#125;\n\n&#125;\n\n\n\n\n\n\n\n\n\n\n执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。\n38、数据类型之间的转换：1、 如何将字符串转换为基本数据类型？\n\n\n\n\n\n\n\n\n调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型；\n2、 如何将基本数据类型转换为字符串？\n\n\n\n\n\n\n\n\n一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf()方法返回相应字符串\n39、如何将字符串反转？\n\n\n\n\n\n\n\n\n使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。\n&#x2F;&#x2F; StringBuffer reverse\nStringBuffer stringBuffer &#x3D; new StringBuffer();\nstringBuffer.append(&quot;abcdefg&quot;);\nSystem.out.println(stringBuffer.reverse()); &#x2F;&#x2F; gfedcba\n&#x2F;&#x2F; StringBuilder reverse\nStringBuilder stringBuilder &#x3D; new StringBuilder();\nstringBuilder.append(&quot;abcdefg&quot;);\nSystem.out.println(stringBuilder.reverse()); &#x2F;&#x2F; gfedcba\n40、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？\n\n\n\n\n\n\n\n\nString s1 &#x3D; &quot;你好&quot;;\nString s2 &#x3D; new String(s1.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;);\n\nnew一个新的String对象，并指定参数进行字符串的转换。\n41、日期和时间\n\n\n\n\n\n\n\n\n1、如何取得年、月、日、时、分、秒？创建java.util.Calendar 实例，调用其get()方法传入不同的参数即可获得参数所对应的值。Java 8中可以使用java.time.LocalDateTimel来获取\npublic class DateTimeTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tCalendar cal &#x3D; Calendar.getInstance();\n\t\tSystem.out.println(cal.get(Calendar.YEAR));\n\t\tSystem.out.println(cal.get(Calendar.MONTH));\t&#x2F;&#x2F; 0 - 11\n\t\tSystem.out.println(cal.get(Calendar.DATE));\n\t\tSystem.out.println(cal.get(Calendar.HOUR_OF_DAY));\n\t\tSystem.out.println(cal.get(Calendar.MINUTE));\n\t\tSystem.out.println(cal.get(Calendar.SECOND));\n\n\t\t&#x2F;&#x2F; Java 8\n\t\tLocalDateTime dt &#x3D; LocalDateTime.now();\n\t\tSystem.out.println(dt.getYear());\n\t\tSystem.out.println(dt.getMonthValue());\t\t&#x2F;&#x2F; 1 - 12\n\t\tSystem.out.println(dt.getDayOfMonth());\n\t\tSystem.out.println(dt.getHour());\n\t\tSystem.out.println(dt.getMinute());\n\t\tSystem.out.println(dt.getSecond());\n\t&#125;\n&#125;\n42、打印昨天的当前时刻。\n\n\n\n\n\n\n\n\nimport java.util.Calendar;\n\nclass YesterdayCurrent &#123;\n public static void main(String[] args)&#123;\n     Calendar cal &#x3D; Calendar.getInstance();\n     cal.add(Calendar.DATE, -1);\n     System.out.println(cal.getTime());\n &#125;\n&#125;\n\n&#x2F;&#x2F; java 8 新特性\nimport java.time.LocalDateTime;\n\nclass YesterdayCurrent &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tLocalDateTime today &#x3D; LocalDateTime.now();\n\t\tLocalDateTime yesterday &#x3D; today.minusDays(1); &#x2F;&#x2F; minus days -》减去天数\n\n\t\tSystem.out.println(yesterday);\n\t&#125;\n&#125;\n\n43、比较一下Java和JavaSciprt\n\n\n\n\n\n\n\n\nJavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。\n下面对两种语言间的异同作如下比较：\n基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率）强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。代码格式不一样。\n\n\n\n\nJava语言\nJavaScript语言\n\n\n\n语言特点\n面向对象语言\n基于对象的脚本语言\n\n\n解释和编译\njava 源代码执行前必须经过编译\n解释性编程语言，源代码不需要经过编译，有浏览器解释执行\n\n\n变量类型\n强类型变量，所有变量在编译之前必须作声明\n弱类型变量，在使用变量前可以不作声明，解释器在运行时检查判断器数据类型。\n\n\n44、什么时候用断言（assert）？\n\n\n\n\n\n\n\n\n断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式的值为false，那么系统会报告一个AssertionError。断言的使用如下面的代码所示：\nassert(a &gt; 0); // throws an AssertionError if a &lt;= 0\n45、Error和Exception有什么区别？\n\n\n\n\n\n\n\n\n超类Throwable分为两个重要的子类：\n1、Error （错误），这一类通常是系统级别的错误，也是程序无法处理的错误，通常是Java虚拟机出现问题才会报出Error类型的错误，如OutOfMemoryError这类错误。\n2、Exception（异常），这一类表示程序本身可以处理的异常。有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ClassNoFoundException）和 ArrayIndexOutOfBoundException。\n3、异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。\n46、try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?\n\n\n\n\n\n\n\n\n会执行，在方法返回调用者前执行。\n在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，就会返回修改后的值。显然，在finally中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊 的事情，Java中也可以通过提升编译器的语法检查级别来产生警告或错误。\n47、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？\n\n\n\n\n\n\n\n\nJava通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。\nJava的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。\n一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；\ntry用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；throw语句用来明确地抛出一个异常；throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally为确保一段代码不管发生什么异常状况都要被执行；try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。\n48、运行时异常与受检异常有何异同？\n\n\n\n\n\n\n\n\n异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在_Effective Java_中对异常的使用给出了以下指导原则：\n\n不要将异常处理用于正常的控制流\n（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）\n\n对可以恢复的情况使用受检异常，对编程错误使用运行时异常\n\n避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）\n\n优先使用标准的异常\n\n每个方法抛出的异常都要有文档\n\n保持异常的原子性\n\n不要在catch中忽略掉捕获到的异常\n\n\n49、列出一些你常见的运行时异常？\n\n\n\n\n\n\n\n\n\n数组下标越界异常 ArrayIndexOutOfBoundsException\n空指针异常 NullPointerException\n类不存在异常 ClassNotFoundException\nSQL语句异常 SQLException\n方法参数异常 IllegalArgumentException\n\n50、阐述final、finally、finalize的区别\n\n\n\n\n\n\n\n\n\nfinal：修饰符（关键字）有三种用法：\n修饰类：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。\n修饰方法：被声明为final的方法也同样只能使用，不能在子类中被重写。\n修饰变量：将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。\n\n\nfinally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。\nfinalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。\n\n51、类ExampleA继承Exception，类ExampleB继承ExampleAtry &#123;\n    throw new ExampleB(&quot;b&quot;)\n&#125; catch（ExampleA e）&#123;\n    System.out.println(&quot;ExampleA&quot;);\n&#125; catch（Exception e）&#123;\n    System.out.println(&quot;Exception&quot;);\n&#125;\n\n\n\n\n\n\n\n\n\n\n请问执行此段代码的输出是什么？答：输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取ExampleA类型异常的catch块能够抓住try块中抛出的ExampleB类型的异常）\n52、List、Set、Map是否继承自Collection接口？\n\n\n\n\n\n\n\n\nList、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。\n53、阐述ArrayList、LinkedList的存储性能和特性方面的区别。\n\n\n\n\n\n\n\n\n\n数据结构实现:\nArrayList :基于数组，容量不够时候采用复制方式扩容。\nLinkedList:使用双向链表实现。\n\n\n随机访问效率:\nArrayList 比 LinkedList 在随机访问的时候效率要高，因为LinkedList 是链表结构，需要依次查找元素，性能不高。\n\n\n增加和删除效率:\n LinkedList 首尾操作具备很高效率。ArrayList 的头部性能稍差。\n\n\n线程安全:\nArrayList 和 LinkList 都是不同步的，不保证线程安全。\n\n\n综合来说：\n需要频繁读取集合中的元素时，更推荐使用 Arrayist；\n而在头尾增删操作较多时，更推荐使用 LinkedList。\nArrayList综合性能优秀，优选之！\n\n\n\n54、Collection和Collections的区别？\n\n\n\n\n\n\n\n\nCollection是一个接口，它是Set、List等容器的父接口。\nCollections是集合类的工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。\n55、List、Map、Set三个接口存取元素时，各有什么特点？\n\n\n\n\n\n\n\n\n\nList 线性表：有序可以重复的集合，元素有先后次序，可以按照位置访问元素， 可以存储null\nSet ：元素不重复集合，重复元素算一个，不保证元素的先后次序，可以存储一个 null \nMap：元素按照key：value成对存储，可以按照key查找value，查找性能好，key不可以重复，可以存储一个null key\n\n56、TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？\n\n\n\n\n\n\n\n\nTreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。\nCollections工具类的sort方法有两种重载的形式：\n第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；\n第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。    \n57、Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?\n\n\n\n\n\n\n\n\n**sleep()**方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。\n**wait()**是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。\n进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的CPU资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。时下很时髦的Node.js就采用了单线程异步I/O的工作模式。\n58、线程的sleep()方法和yield()方法有什么区别？\n\n\n\n\n\n\n\n\n① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。\n59、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？\n\n\n\n\n\n\n\n\n不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（**注意不是等待池哦**）中等待对象的锁。\n60、请说出与线程同步以及线程调度相关的方法。\n\n\n\n\n\n\n\n\n\nwait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；\nsleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；\nnotify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；\nnotityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；\n\n61、编写多线程程序有几种实现方式？\n\n\n\n\n\n\n\n\n\n继承Thread类，重写run()方法来定义线程的行为；\n实现Runnable接口，重写run()方法来定义线程的行为；\n推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活；\n实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值。\n\n62、synchronized关键字的用法？\n\n\n\n\n\n\n\n\n\n修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁\n修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁\n修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。\n\n（1）synchronized作用于实例方法所谓的实例对象锁就是用synchronized修饰实例对象中的实例方法，注意是实例方法不包括静态方法，如下：\npublic class AccountingSync implements Runnable &#123;\n\t&#x2F;&#x2F; 共享资源(临界资源)\n\tstatic int i &#x3D; 0;\n\n\t&#x2F;**\n\t * synchronized 修饰实例方法\n\t *&#x2F;\n\tpublic synchronized void increase() &#123;\n\t\ti++;\n\t&#125;\n\n\t@Override\n\tpublic void run() &#123;\n\t\tfor (int j &#x3D; 0; j &lt; 1000000; j++) &#123;\n\t\t\tincrease();\n\t\t&#125;\n\t&#125;\n\n\tpublic static void main(String[] args) throws InterruptedException &#123;\n\t\tAccountingSync instance &#x3D; new AccountingSync();\n\t\tThread t1 &#x3D; new Thread(instance);\n\t\tThread t2 &#x3D; new Thread(instance);\n\t\tt1.start();\n\t\tt2.start();\n\t\tt1.join();\n\t\tt2.join();\n\t\tSystem.out.println(i);\n\t&#125;\n\t&#x2F;**\n\t * 输出结果: 2000000\n\t *&#x2F;\n&#125;\n\n上述代码与前面不同的是我们同时创建了两个新实例AccountingSyncBad，然后启动两个不同的线程对共享变量i进行操作，但很遗憾操作结果是1452317而不是期望结果2000000，因为上述代码犯了严重的错误，虽然我们使用synchronized修饰了increase方法，但却new了两个不同的实例对象，这也就意味着存在着两个不同的实例对象锁，因此t1和t2都会进入各自的对象锁，也就是说t1和t2线程使用的是不同的锁，因此线程安全是无法保证的。解决这种困境的的方式是将synchronized作用于静态的increase方法，这样的话，对象锁就当前类对象，由于无论创建多少个实例对象，但对于的类对象拥有只有一个，所有在这样的情况下对象锁就是唯一的。下面我们看看如何使用将synchronized作用于静态的increase方法。\n（2）synchronized作用于静态方法当synchronized作用于静态方法时，其锁就是当前类的class对象锁。由于静态成员不专属于任何一个实例对象，是类成员，因此通过class对象锁可以控制静态 成员的并发操作。需要注意的是如果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的class对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁，看如下代码:\npublic class AccountingSyncClass implements Runnable&#123;\n    static int i&#x3D;0;\n\n    &#x2F;**\n     * 作用于静态方法,锁是当前class对象,也就是\n     * AccountingSyncClass类对应的class对象\n     *&#x2F;\n    public static synchronized void increase()&#123;\n        i++;\n    &#125;\n\n    &#x2F;**\n     * 非静态,访问时锁不一样不会发生互斥\n     *&#x2F;\n    public synchronized void increase4Obj()&#123;\n        i++;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        for(int j&#x3D;0;j&lt;1000000;j++)&#123;\n            increase();\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        &#x2F;&#x2F;new新实例\n        Thread t1&#x3D;new Thread(new AccountingSyncClass());\n        &#x2F;&#x2F;new新实例\n        Thread t2&#x3D;new Thread(new AccountingSyncClass());\n        &#x2F;&#x2F;启动线程\n        t1.start();t2.start();\n\n        t1.join();t2.join();\n        System.out.println(i);\n    &#125;\n&#125;\n\n\n由于synchronized关键字修饰的是静态increase方法，与修饰实例方法不同的是，其锁对象是当前类的class对象。注意代码中的increase4Obj方法是实例方法，其对象锁是当前实例对象，如果别的线程调用该方法，将不会产生互斥现象，毕竟锁对象不同，但我们应该意识到这种情况下可能会发现线程安全问题(操作了共享静态变量i)。\n3）synchronized同步代码块除了使用关键字修饰实例方法和静态方法外，还可以使用同步代码块，在某些情况下，我们编写的方法体可能比较大，同时存在一些比较耗时的操作，而需要同步的代码又只有一小部分，如果直接对整个方法进行同步操作，可能会得不偿失，此时我们可以使用同步代码块的方式对需要同步的代码进行包裹，这样就无需对整个方法进行同步操作了，同步代码块的使用示例如下：\npublic class AccountingSync implements Runnable&#123;\n    static AccountingSync instance&#x3D;new AccountingSync();\n    static int i&#x3D;0;\n    @Override\n    public void run() &#123;\n        &#x2F;&#x2F;省略其他耗时操作....\n        &#x2F;&#x2F;使用同步代码块对变量i进行同步操作,锁对象为instance\n        synchronized(instance)&#123;\n            for(int j&#x3D;0;j&lt;1000000;j++)&#123;\n                    i++;\n              &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        Thread t1&#x3D;new Thread(instance);\n        Thread t2&#x3D;new Thread(instance);\n        t1.start();t2.start();\n        t1.join();t2.join();\n        System.out.println(i);\n    &#125;\n&#125;\n\n\n从代码看出，将synchronized作用于一个给定的实例对象instance，即当前实例对象就是锁对象，每次当线程进入synchronized包裹的代码块时就会要求当前线程持有instance实例对象锁，如果当前有其他线程正持有该对象锁，那么新到的线程就必须等待，这样也就保证了每次只有一个线程执行i++;操作。当然除了instance作为对象外，我们还可以使用this对象(代表当前实例)或者当前类的class对象作为锁，如下代码：\n&#x2F;&#x2F;this,当前实例对象锁\nsynchronized(this)&#123;\n    for(int j&#x3D;0;j&lt;1000000;j++)&#123;\n        i++;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;class对象锁\nsynchronized(AccountingSync.class)&#123;\n    for(int j&#x3D;0;j&lt;1000000;j++)&#123;\n        i++;\n    &#125;\n&#125;\n\n\n63、举例说明同步和异步。\n\n\n\n\n\n\n\n\n如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。\n当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。\n64、启动一个线程是调用run()还是start()方法？\n\n\n\n\n\n\n\n\n启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会 立即运行。run()方法是线程启动后要进行回调（callback）的方法。\n65、什么是线程池（thread pool）？\n\n\n\n\n\n\n\n\n在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：\n\nnewCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\nnewFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\nnewScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。\nnewSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n\n66、线程的基本状态以及状态之间的关系？​            线程生命周期图：\n\n\n\n\n\n\n\n\n\n\n其中Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。\n67、简述synchronized 和java.util.concurrent.locks.Lock的异同？\n\n\n\n\n\n\n\n\nLock是Java 5以后引入的新的API，和关键字synchronized相比\n相同点：Lock 能完成synchronized所实现的所有功能；\n不同点：Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外部资源的最好的地方）。\n68、Java中如何实现序列化，有什么意义？\n\n\n\n\n\n\n\n\n序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(c)方法就可以将实现对象写出（即保存其状态）；\n如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject(Object)方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（可以参考第29题）。\n69、Java中有几种类型的流？\n\n\n\n\n\n\n\n\n字节流和字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。\n关于Java的I/O需要注意的有两点：\n\n两种对称性（输入和输出的对称性，字节和字符的对称性）；\n两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。\n\n\n笔试题：利用文件流实现文件拷贝。\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic final class MyUtil &#123;\n\n\tprivate MyUtil() &#123;\n\t\tthrow new AssertionError();\n\t&#125;\n\n\tpublic static void fileCopy(String source, String target) throws IOException &#123;\n\t\ttry (InputStream in &#x3D; new FileInputStream(source)) &#123;\n\t\t\ttry (OutputStream out &#x3D; new FileOutputStream(target)) &#123;\n\t\t\t\tbyte[] buffer &#x3D; new byte[4096];\n\t\t\t\tint bytesToRead;\n\t\t\t\twhile((bytesToRead &#x3D; in.read(buffer)) !&#x3D; -1) &#123;\n\t\t\t\t\tout.write(buffer, 0, bytesToRead);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\tpublic static void fileCopyNIO(String source, String target) throws IOException &#123;\n\t\ttry (FileInputStream in &#x3D; new FileInputStream(source)) &#123;\n\t\t\ttry (FileOutputStream out &#x3D; new FileOutputStream(target)) &#123;\n\t\t\t\tFileChannel inChannel &#x3D; in.getChannel();\n\t\t\t\tFileChannel outChannel &#x3D; out.getChannel();\n\t\t\t\tByteBuffer buffer &#x3D; ByteBuffer.allocate(4096);\n\t\t\t\twhile(inChannel.read(buffer) !&#x3D; -1) &#123;\n\t\t\t\t\tbuffer.flip();\n\t\t\t\t\toutChannel.write(buffer);\n\t\t\t\t\tbuffer.clear();\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数？\n\n\n\n\n\n\n\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic final class MyUtil &#123;\n\n\t&#x2F;&#x2F; 工具类中的方法都是静态方式访问的因此将构造器私有不允许创建对象(绝对好习惯)\n\tprivate MyUtil() &#123;\n\t\tthrow new AssertionError();\n\t&#125;\n\n\t&#x2F;**\n\t * 统计给定文件中给定字符串的出现次数\n\t * \n\t * @param filename  文件名\n\t * @param word 字符串\n\t * @return 字符串在文件中出现的次数\n\t *&#x2F;\n\tpublic static int countWordInFile(String filename, String word) &#123;\n\t\tint counter &#x3D; 0;\n\t\ttry (FileReader fr &#x3D; new FileReader(filename)) &#123;\n\t\t\ttry (BufferedReader br &#x3D; new BufferedReader(fr)) &#123;\n\t\t\t\tString line &#x3D; null;\n\t\t\t\twhile ((line &#x3D; br.readLine()) !&#x3D; null) &#123;\n\t\t\t\t\tint index &#x3D; -1;\n\t\t\t\t\twhile (line.length() &gt;&#x3D; word.length() &amp;&amp; (index &#x3D; line.indexOf(word)) &gt;&#x3D; 0) &#123;\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\tline &#x3D; line.substring(index + word.length());\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125; catch (Exception ex) &#123;\n\t\t\tex.printStackTrace();\n\t\t&#125;\n\t\treturn counter;\n\t&#125;\n\n&#125;\n\n\n71、如何用Java代码列出一个目录下所有的文件？\n\n\n\n\n\n\n\n\nimport java.io.File;\n\nclass Test12 &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tFile f &#x3D; new File(&quot;&#x2F;Users&#x2F;Hao&#x2F;Downloads&quot;);\n\t\tfor(File temp : f.listFiles()) &#123;\n\t\t\tif(temp.isFile()) &#123;\n\t\t\t\tSystem.out.println(temp.getName());\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nimport java.io.File;\n\n&#x2F;&#x2F; 如果需要对文件夹继续展开 代码如下：\nclass Test12 &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tshowDirectory(new File(&quot;&#x2F;Users&#x2F;Hao&#x2F;Downloads&quot;));\n\t&#125;\n\n\tpublic static void showDirectory(File f) &#123;\n\t\t_walkDirectory(f, 0);\n\t&#125;\n\n\tprivate static void _walkDirectory(File f, int level) &#123;\n\t\tif(f.isDirectory()) &#123;\n\t\t\tfor(File temp : f.listFiles()) &#123;\n\t\t\t\t_walkDirectory(temp, level + 1);\n\t\t\t&#125;\n\t\t&#125;\n\t\telse &#123;\n\t\t\tfor(int i &#x3D; 0; i &lt; level - 1; i++) &#123;\n\t\t\t\tSystem.out.print(&quot;\\t&quot;);\n\t\t\t&#125;\n\t\t\tSystem.out.println(f.getName());\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n\n72、用Java的套接字编程实现一个多线程的回显（echo）服务器。\n\n\n\n\n\n\n\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EchoServer &#123;\n\n\tprivate static final int ECHO_SERVER_PORT &#x3D; 6789;\n\n\tpublic static void main(String[] args) &#123;\t\t\n\t\ttry(ServerSocket server &#x3D; new ServerSocket(ECHO_SERVER_PORT)) &#123;\n\t\t\tSystem.out.println(&quot;服务器已经启动...&quot;);\n\t\t\twhile(true) &#123;\n\t\t\t\tSocket client &#x3D; server.accept();\n\t\t\t\tnew Thread(new ClientHandler(client)).start();\n\t\t\t&#125;\n\t\t&#125; catch (IOException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n\n\tprivate static class ClientHandler implements Runnable &#123;\n\t\tprivate Socket client;\n\n\t\tpublic ClientHandler(Socket client) &#123;\n\t\t\tthis.client &#x3D; client;\n\t\t&#125;\n\n\t\t@Override\n\t\tpublic void run() &#123;\n\t\t\ttry(BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(client.getInputStream()));\n\t\t\t\t\tPrintWriter pw &#x3D; new PrintWriter(client.getOutputStream())) &#123;\n\t\t\t\tString msg &#x3D; br.readLine();\n\t\t\t\tSystem.out.println(&quot;收到&quot; + client.getInetAddress() + &quot;发送的: &quot; + msg);\n\t\t\t\tpw.println(msg);\n\t\t\t\tpw.flush();\n\t\t\t&#125; catch(Exception ex) &#123;\n\t\t\t\tex.printStackTrace();\n\t\t\t&#125; finally &#123;\n\t\t\t\ttry &#123;\n\t\t\t\t\tclient.close();\n\t\t\t\t&#125; catch (IOException e) &#123;\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n&#125;\n\n\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class EchoClient &#123;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tSocket client &#x3D; new Socket(&quot;localhost&quot;, 6789);\n\t\tScanner sc &#x3D; new Scanner(System.in);\n\t\tSystem.out.print(&quot;请输入内容: &quot;);\n\t\tString msg &#x3D; sc.nextLine();\n\t\tsc.close();\n\t\tPrintWriter pw &#x3D; new PrintWriter(client.getOutputStream());\n\t\tpw.println(msg);\n\t\tpw.flush();\n\t\tBufferedReader br &#x3D; new BufferedReader(new InputStreamReader(client.getInputStream()));\n\t\tSystem.out.println(br.readLine());\n\t\tclient.close();\n\t&#125;\n&#125;\n\n\n\n如果希望用NIO的多路复用套接字实现服务器，代码如下所示。NIO的操作虽然带来了更好的性能，但是有些操作是比较底层的，对于初学者来说还是有些难于理解。\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\n\npublic class EchoServerNIO &#123;\n\n\tprivate static final int ECHO_SERVER_PORT &#x3D; 6789;\n\tprivate static final int ECHO_SERVER_TIMEOUT &#x3D; 5000;\n\tprivate static final int BUFFER_SIZE &#x3D; 1024;\n\n\tprivate static ServerSocketChannel serverChannel &#x3D; null;\n\tprivate static Selector selector &#x3D; null;\t&#x2F;&#x2F; 多路复用选择器\n\tprivate static ByteBuffer buffer &#x3D; null;\t&#x2F;&#x2F; 缓冲区\n\n\tpublic static void main(String[] args) &#123;\n\t\tinit();\n\t\tlisten();\n\t&#125;\n\n\tprivate static void init() &#123;\n\t\ttry &#123;\n\t\t\tserverChannel &#x3D; ServerSocketChannel.open();\n\t\t\tbuffer &#x3D; ByteBuffer.allocate(BUFFER_SIZE);\n\t\t\tserverChannel.socket().bind(new InetSocketAddress(ECHO_SERVER_PORT));\n\t\t\tserverChannel.configureBlocking(false);\n\t\t\tselector &#x3D; Selector.open();\n\t\t\tserverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\t\t&#125; catch (Exception e) &#123;\n\t\t\tthrow new RuntimeException(e);\n\t\t&#125;\n\t&#125;\n\n\tprivate static void listen() &#123;\n\t\twhile (true) &#123;\n\t\t\ttry &#123;\n\t\t\t\tif (selector.select(ECHO_SERVER_TIMEOUT) !&#x3D; 0) &#123;\n\t\t\t\t\tIterator&lt;SelectionKey&gt; it &#x3D; selector.selectedKeys().iterator();\n\t\t\t\t\twhile (it.hasNext()) &#123;\n\t\t\t\t\t\tSelectionKey key &#x3D; it.next();\n\t\t\t\t\t\tit.remove();\n\t\t\t\t\t\thandleKey(key);\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125; catch (Exception e) &#123;\n\t\t\t\te.printStackTrace();\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\tprivate static void handleKey(SelectionKey key) throws IOException &#123;\n\t\tSocketChannel channel &#x3D; null;\n\n\t\ttry &#123;\n\t\t\tif (key.isAcceptable()) &#123;\n\t\t\t\tServerSocketChannel serverChannel &#x3D; (ServerSocketChannel) key.channel();\n\t\t\t\tchannel &#x3D; serverChannel.accept();\n\t\t\t\tchannel.configureBlocking(false);\n\t\t\t\tchannel.register(selector, SelectionKey.OP_READ);\n\t\t\t&#125; else if (key.isReadable()) &#123;\n\t\t\t\tchannel &#x3D; (SocketChannel) key.channel();\n\t\t\t\tbuffer.clear();\n\t\t\t\tif (channel.read(buffer) &gt; 0) &#123;\n\t\t\t\t\tbuffer.flip();\n\t\t\t\t\tCharBuffer charBuffer &#x3D; CharsetHelper.decode(buffer);\n\t\t\t\t\tString msg &#x3D; charBuffer.toString();\n\t\t\t\t\tSystem.out.println(&quot;收到&quot; + channel.getRemoteAddress() + &quot;的消息：&quot; + msg);\n\t\t\t\t\tchannel.write(CharsetHelper.encode(CharBuffer.wrap(msg)));\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\tchannel.close();\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125; catch (Exception e) &#123;\n\t\t\te.printStackTrace();\n\t\t\tif (channel !&#x3D; null) &#123;\n\t\t\t\tchannel.close();\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n&#125;\n\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\n\npublic final class CharsetHelper &#123;\n private static final String UTF_8 &#x3D; &quot;UTF-8&quot;;\n private static CharsetEncoder encoder &#x3D; Charset.forName(UTF_8).newEncoder();\n private static CharsetDecoder decoder &#x3D; Charset.forName(UTF_8).newDecoder();\n\n private CharsetHelper() &#123;\n &#125;\n\n public static ByteBuffer encode(CharBuffer in) throws CharacterCodingException&#123;\n     return encoder.encode(in);\n &#125;\n\n public static CharBuffer decode(ByteBuffer in) throws CharacterCodingException&#123;\n     return decoder.decode(in);\n &#125;\n&#125;\n\n\n73、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？\n\n\n\n\n\n\n\n\nXML文档定义方式：有两种定义形式，dtd文档类型定义和schema模式。本质区别：schema本身是xml的，可以被XML解析器解析(这也是从DTD上发展schema的根本目的)普通区别：\nschema 是内容开放模型，可扩展，功能性强，而DTD可扩展性差。shema 支持丰富的数据类型，而 DTD不支持元素的数据类型，对属性的类型定义也很有限。schema 支持命名空间机制，而DTD不支持。schema 可针对不同情况对整个XML 文档或文档局部进行验证；而 DTD缺乏这种灵活性。schema 完全遵循XML规范，符合XML语法，可以和DOM结合使用，功能强大；而DTD 语法本身有自身的语法和要求，难以学习。解析XML文档方式：\nDOM解析： DOM的全称是Document Object Model，也即文档对象模型。在应用程序中，基于DOM的XML分析器将一个XML文档转换成一个对象模型的集合（通常称DOM树），应用程序正是通过对这个对象模型的操作，来实现对XML文档数据的操作。通过DOM接口，应用程序可以在任何时候访问XML文档中的任何一部分数据，因此，这种利用DOM接口的机制也被称作随机访问机制。SAX解析：SAX的全称是Simple APIs for XML，也即XML简单应用程序接口。与DOM不同，SAX提供的访问模式是一种顺序模式，这是一种快速读写XML数据的方式。当使用SAX分析器对XML文档进行分析时，会触发一系列事件，并激活相应的事件处理函数，应用程序通过这些事件处理函数实现对XML文档的访问，因而SAX接口也被称作事件驱动接口。JDOM解析：JDOM采用了Java中的Collection架构来封装集合，是Java爱好者更加熟悉的模式DOM4J解析：xml解析器一次性把整个xml文档加载进内存，然后在内存中构建一颗Document的对象树，通过Document对象，得到树上的节点对象，通过节点对象访问（操作）到xml文档的内容\n74、你在项目中哪些地方用到了XML？\n\n\n\n\n\n\n\n\nXML的主要作用有两个方面：数据交换和信息配置。在做数据交换时，XML将数据用标签组装成起来，然后压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再从XML文件中还原相关信息进行处理，XML曾经是异构系统间交换数据的事实标准，但此项功能几乎已经被JSON（JavaScript Object Notation）取而代之。当然，目前很多软件仍然使用XML来存储配置信息，我们在很多项目中通常也会将作为配置信息的硬代码写在XML文件中，Java的很多框架也是这么做的，而且这些框架都选择了dom4j作为处理XML的工具，因为Sun公司的官方API实在不怎么好用。\nSQL语句。\n75、阐述JDBC操作数据库的步骤\n\n\n\n\n\n\n\n\n\n加载驱动\n创建链接\n创建语句\n执行语句\n处理结果\n关闭资源\n\n76、Statement和PreparedStatement有什么区别？哪个性能更好？\n\n\n\n\n\n\n\n\nStatement 和 PreparedStatement之间的关系和区别.关系：PreparedStatement继承自Statement,都是接口区别：PreparedStatement可以使用占位符，是预编译的，批处理比Statement效率高\n详解：\n（1）PreparedStatement：表示预编译的 SQL 语句的对象。SQL 语句被预编译并存储在 PreparedStatement 对象中。然后可以使用此对象多次高效地执行该语句。注：用于设置 IN 参数值的设置方法（setShort、setString 等等）必须指定与输入参数的已定义 SQL 类型兼容的类型。例如，如果 IN 参数具有 SQL 类型 INTEGER，那么应该使用 setInt 方法，问号的位置也是应该注意的，因为第一个问好的位置为1，第二个问号的位置为2.以此类推。\n（2）Statement:用于执行静态 SQL 语句并返回它所生成结果的对象。在默认情况下，同一时间每个 Statement 对象只能打开一个 ResultSet 对象。因此，如果读取一个 ResultSet 对象与另一个交叉，则这两个对象必须是由不同的 Statement 对象生成的。如果存在某个语句的打开的当前 ResultSet 对象，则 Statement 接口中的所有执行方法都会隐式关闭它。如以下操作：创建statement对象\n77、使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？\n\n\n\n\n\n\n\n\n要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的setFetchSize()方法指定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能可以使用PreparedStatement语句构建批处理，将若干SQL语句置于一个批处理中执行。\n78、在进行数据库编程时，连接池有什么作用？\n\n\n\n\n\n\n\n\n由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要进行TCP四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于Java的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid等。\n79、什么是DAO模式？\n\n\n\n\n\n\n\n\nDAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。\nDAO模式实际上包含了两个模式：\n\nData Accessor（数据访问器）\nData Object（数据对象）\n\n前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。\n80、事务的特性（ACID）是指什么？事务的隔离级别有哪些？\n\n\n\n\n\n\n\n\n\n**原子性(Atomic)**：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败；\n**一致性(Consistent)**：事务结束后系统状态是一致的；\n**隔离性(Isolated)**：并发执行的事务彼此无法看到对方的中间状态；\n**持久性(Durable)**：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。\n\n\nSQL的标准事务隔离级别包括：\n读未提交（read uncommitted）： 一个事务还没有提交时，它做的变更就能被别的事务看到。\n读提交（read committed）： 一个事物提交之后，它做的变更才会被其他事务看到。\n可重复读（repeatable read）： 一个事物执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。未提交变更对其他事务也是不可见的。\n串行化（serializable）： 对于同一行记录，写会加“写锁”，读会加“读锁”，当出现锁冲突时，后访问的事务需要等前一个事务执行完成，才能继续执行。\n\n\n\n隔离级别\n脏读\n不可重复读\n幻读\n第一类丢失更新\n第二类丢失更新\n\n\n\nREAD UNCOMMITED\n允许\n允许\n允许\n不允许\n允许\n\n\nREAD COMMITTED\n不允许\n允许\n允许\n不允许\n允许\n\n\nREPEATABLE READ\n不允许\n不允许\n允许\n不允许\n不允许\n\n\nSERIALIZABLE\n不允许\n不允许\n不允许\n不允许\n不允许\n\n\n\n可能导致的问题有\n1.脏读： 一个事务读到另一个事务未提交的更新数据。\n2.不可重复读： 一个事务两次读同一行数据，可是这两次读到的数据不一样。\n3.幻读： 一个事务执行两次查询，但第二次查询比第一次查询多出了一些数据行。\n81、JDBC中如何进行事务处理？\n\n\n\n\n\n\n\n\nConnection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务；当事务完成后用commit()显式提交事务；如果在事务处理过程中发生异常则通过rollback()进行事务回滚。除此之外，从JDBC 3.0中还引入了Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。\n\n82、JDBC能否处理Blob和Clob？\n\n\n\n\n\n\n\n\n Blob是指二进制大对象（Binary Large Object），而Clob是指大字符对象（Character Large Objec），因此其中Blob是为存储大的二进制数据而设计的，而Clob是为存储大的文本数据而设计的。JDBC的PreparedStatement和ResultSet都提供了相应的方法来支持Blob和Clob操作。下面的代码展示了如何使用JDBC操作LOB： 下面以MySQL数据库为例，创建一个张有三个字段的用户表，包括编号（id）、姓名（name）和照片（photo），建表语句如下：\n create table tb_user\n(\nid int primary key auto_increment,\nname varchar(20) unique not null,\nphoto longblob\n);\n\n\n\n 下面的Java代码向数据库中插入一条记录：\n import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\nclass JdbcLobTest &#123;\n public static void main(String[] args) &#123;\n\tConnection con &#x3D; null;\n\ttry &#123;\n\t\t&#x2F;&#x2F; 1. 加载驱动（Java6以上版本可以省略）\n\t\tClass.forName(&quot;com.mysql.jdbc.Driver&quot;);\n\t\t&#x2F;&#x2F; 2. 建立连接\n\t\tcon &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot;, &quot;root&quot;, &quot;123456&quot;);\n\t\t&#x2F;&#x2F; 3. 创建语句对象\n\t\tPreparedStatement ps &#x3D; con.prepareStatement(&quot;insert into tb_user values (default, ?, ?)&quot;);\n\t\tps.setString(1, &quot;hzy&quot;);\t\t\t\t&#x2F;&#x2F; 将SQL语句中第一个占位符换成字符串\n\t\ttry (InputStream in &#x3D; new FileInputStream(&quot;test.jpg&quot;)) &#123;\t&#x2F;&#x2F; Java 7的TWR\n\t\t\tps.setBinaryStream(2, in);\t\t&#x2F;&#x2F; 将SQL语句中第二个占位符换成二进制流\n\t\t\t&#x2F;&#x2F; 4. 发出SQL语句获得受影响行数\n\t\t\tSystem.out.println(ps.executeUpdate() &#x3D;&#x3D; 1 ? &quot;插入成功&quot; : &quot;插入失败&quot;);\n\t\t&#125; catch(IOException e) &#123;\n\t\t\tSystem.out.println(&quot;读取照片失败!&quot;);\n\t\t&#125;\n\t&#125; catch (ClassNotFoundException | SQLException e) &#123;\t\t&#x2F;&#x2F; Java 7的多异常捕获\n\t\te.printStackTrace();\n\t&#125; finally &#123;\t&#x2F;&#x2F; 释放外部资源的代码都应当放在finally中保证其能够得到执行\n\t\ttry &#123;\n\t\t\tif(con !&#x3D; null &amp;&amp; !con.isClosed()) &#123;\n\t\t\t\tcon.close();\t&#x2F;&#x2F; 5. 释放数据库连接 \n\t\t\t\tcon &#x3D; null;     &#x2F;&#x2F; 指示垃圾回收器可以回收该对象\n\t\t\t&#125;\n\t\t&#125; catch (SQLException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n&#125;\n\n }\n83、简述正则表达式及其用途\n\n\n\n\n\n\n\n\n在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。\n计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。\n84、Java中是如何支持正则表达式操作的？\n\n\n\n\n\n\n\n\nJava中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，请参考下面面试题的代码。\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass RegExpTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tString str &#x3D; &quot;北京市(朝阳区)(西城区)(海淀区)&quot;;\n\t\tPattern p &#x3D; Pattern.compile(&quot;.*?(?&#x3D;\\\\()&quot;);\n\t\tMatcher m &#x3D; p.matcher(str);\n\t\tif(m.find()) &#123;\n\t\t\tSystem.out.println(m.group());\n\t\t&#125;\n\t&#125;\n&#125;\n85、获得一个类的类对象有哪些方式？\n\n\n\n\n\n\n\n\n\n方法1：类型.class，例如：String.class\n方法2：对象.getClass()，例如：“hello”.getClass()\n方法3：Class.forName()，例如：Class.forName(“java.lang.String”)\n\n86、如何通过反射创建对象？\n\n\n\n\n\n\n\n\n方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance()方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”);\n87、如何通过反射获取和设置对象私有字段的值？\n\n\n\n\n\n\n\n\n可以通过类对象的getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get/set方法来获取/设置字段的值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如ReflectionUtil.get(dog, “owner.car.engine.id”);可以获得dog对象的主人的汽车的引擎的ID号。\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.List;\n\n&#x2F;**\n * 反射工具类\n *\n *&#x2F;\npublic class ReflectionUtil &#123;\n\n\tprivate ReflectionUtil() &#123;\n\t\tthrow new AssertionError();\n\t&#125;\n\n\t&#x2F;**\n\t * 通过反射取对象指定字段(属性)的值\n\t * @param target 目标对象\n\t * @param fieldName 字段的名字\n\t * @throws 如果取不到对象指定字段的值则抛出异常\n\t * @return 字段的值\n\t *&#x2F;\n\tpublic static Object getValue(Object target, String fieldName) &#123;\n\t\tClass&lt;?&gt; clazz &#x3D; target.getClass();\n\t\tString[] fs &#x3D; fieldName.split(&quot;\\\\.&quot;);\n\n\t\ttry &#123;\n\t\t\tfor(int i &#x3D; 0; i &lt; fs.length - 1; i++) &#123;\n\t\t\t\tField f &#x3D; clazz.getDeclaredField(fs[i]);\n\t\t\t\tf.setAccessible(true);\n\t\t\t\ttarget &#x3D; f.get(target);\n\t\t\t\tclazz &#x3D; target.getClass();\n\t\t\t&#125;\n\n\t\t\tField f &#x3D; clazz.getDeclaredField(fs[fs.length - 1]);\n\t\t\tf.setAccessible(true);\n\t\t\treturn f.get(target);\n\t\t&#125;\n\t\tcatch (Exception e) &#123;\n\t\t\tthrow new RuntimeException(e);\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;**\n\t * 通过反射给对象的指定字段赋值\n\t * @param target 目标对象\n\t * @param fieldName 字段的名称\n\t * @param value 值\n\t *&#x2F;\n\tpublic static void setValue(Object target, String fieldName, Object value) &#123;\n\t\tClass&lt;?&gt; clazz &#x3D; target.getClass();\n\t\tString[] fs &#x3D; fieldName.split(&quot;\\\\.&quot;);\n\t\ttry &#123;\n\t\t\tfor(int i &#x3D; 0; i &lt; fs.length - 1; i++) &#123;\n\t\t\t\tField f &#x3D; clazz.getDeclaredField(fs[i]);\n\t\t\t\tf.setAccessible(true);\n\t\t\t\tObject val &#x3D; f.get(target);\n\t\t\t\tif(val &#x3D;&#x3D; null) &#123;\n\t\t\t\t\tConstructor&lt;?&gt; c &#x3D; f.getType().getDeclaredConstructor();\n\t\t\t\t\tc.setAccessible(true);\n\t\t\t\t\tval &#x3D; c.newInstance();\n\t\t\t\t\tf.set(target, val);\n\t\t\t\t&#125;\n\t\t\t\ttarget &#x3D; val;\n\t\t\t\tclazz &#x3D; target.getClass();\n\t\t\t&#125;\n\n\t\t\tField f &#x3D; clazz.getDeclaredField(fs[fs.length - 1]);\n\t\t\tf.setAccessible(true);\n\t\t\tf.set(target, value);\n\t\t&#125;\n\t\tcatch (Exception e) &#123;\n\t\t\tthrow new RuntimeException(e);\n\t\t&#125;\n\t&#125;\n\n&#125;\n\n\n88、如何通过反射调用对象的方法？\n\n\n\n\n\n\n\n\nimport java.lang.reflect.Method;\n\nclass MethodInvokeTest &#123;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tString str &#x3D; &quot;hello&quot;;\n\t\tMethod m &#x3D; str.getClass().getMethod(&quot;toUpperCase&quot;);\n\t\tSystem.out.println(m.invoke(str));\t&#x2F;&#x2F; HELLO\n\t&#125;\n&#125;\n\n\n89、简述一下面向对象的”六原则一法则”\n\n\n\n\n\n\n\n\n单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫”因为专注，所以专业”，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）\n\n里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到”低耦合”，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。)\n\n90、简述一下你了解的设计模式。\n\n\n\n\n\n\n\n\n所谓设计模式，**就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。**在GoF的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共23种设计模式，包括：\nAbstract Factory（抽象工厂模式），\nBuilder（建造者模式），\nFactory Method（工厂方法模式），\nPrototype（原始模型模式），\nSingleton（单例模式）；\nFacade（门面模式），\nAdapter（适配器模式），\nBridge（桥梁模式），\nComposite（合成模式），\nDecorator（装饰模式），\nFlyweight（享元模式），\nProxy（代理模式）；\nCommand（命令模式），\nInterpreter（解释器模式），\nVisitor（访问者模式），\nIterator（迭代子模式），\nMediator（调停者模式），\nMemento（备忘录模式），\nObserver（观察者模式），\nState（状态模式），\nStrategy（策略模式），\nTemplate Method（模板方法模式），\nChain Of Responsibility（责任链模式）。\n面试被问到关于设计模式的知识时，可以拣最常用的作答，例如：\n工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections工具类和I/O系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。\n91、用Java写一个单例类\n\n\n\n\n\n\n\n\n\n饿汉式单例\n\n&#x2F;* 适用于单例模式较少的场景\n如果我们在程序启动后，一定会加载到类，那么用饿汉模式实现的单例简单又实用；\n如果我们是写一些工具类，则优先考虑使用懒汉模式，可以避免提前被加载到内存中，占用系统资源。*&#x2F;\n\npublic class Singleton &#123;\n    private Singleton()&#123;&#125;\n    private static Singleton instance &#x3D; new Singleton();\n    public static Singleton getInstance()&#123;\n        return instance;\n    &#125;\n&#125;\n\n\n懒汉式单例(双重检查锁)\n\n&#x2F;*如果我们在程序启动后，一定会加载到类，那么用饿汉模式实现的单例简单又实用；\n如果我们是写一些工具类，则优先考虑使用懒汉模式，可以避免提前被加载到内存中，占用系统资源。*&#x2F;\n\npublic class Singleton &#123;\n    private static Singleton instance &#x3D; null;\n    private Singleton() &#123;&#125;\n    public static synchronized Singleton getInstance()&#123;\n        if (instance &#x3D;&#x3D; null) instance ＝ new Singleton();\n        return instance;\n    &#125;\n&#125;\n\n\n静态内部类单例\n\n&#x2F;* 屏蔽饿汉式单例模式的内存浪费问题和双重检查锁中synchronized的性能问题，同时考虑避免因为反射破坏单例问题。\n相对而言性能最好\n *&#x2F;\n\n\n\n\n注册式单例\n枚举式单例模式 —–Effective Java推荐单例模式容器式单例模式 —–适用于实例非常多的情况，便于管理，但是是非线程安全的\n\n\n\n92、什么是UML？\n\n\n\n\n\n\n\n\nUML是统一建模语言（Unified Modeling Language）的缩写，它发表于1997年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。\n93、UML中有哪些常用的图？\n\n\n\n\n\n\n\n\nUML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。\n94、用Java写一个冒泡排序\n\n\n\n\n\n\n\n\nimport java.util.Comparator;\n\n&#x2F;**\n * 排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可以相互替换)\n *\n *&#x2F;\npublic interface Sorter &#123;\n\n   &#x2F;**\n    * 排序\n    * @param list 待排序的数组\n    *&#x2F;\n   public &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] list);\n\n   &#x2F;**\n    * 排序\n    * @param list 待排序的数组\n    * @param comp 比较两个对象的比较器\n    *&#x2F;\n   public &lt;T&gt; void sort(T[] list, Comparator&lt;T&gt; comp);\n&#125;\n\n\n\nimport java.util.Comparator;\n\n&#x2F;**\n * 冒泡排序\n * \n *\n *&#x2F;\npublic class BubbleSorter implements Sorter &#123;\n\n\t@Override\n\tpublic &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] list) &#123;\n\t\tboolean swapped &#x3D; true;\n\t\tfor (int i &#x3D; 1, len &#x3D; list.length; i &lt; len &amp;&amp; swapped; ++i) &#123;\n\t\t\tswapped &#x3D; false;\n\t\t\tfor (int j &#x3D; 0; j &lt; len - i; ++j) &#123;\n\t\t\t\tif (list[j].compareTo(list[j + 1]) &gt; 0) &#123;\n\t\t\t\t\tT temp &#x3D; list[j];\n\t\t\t\t\tlist[j] &#x3D; list[j + 1];\n\t\t\t\t\tlist[j + 1] &#x3D; temp;\n\t\t\t\t\tswapped &#x3D; true;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t@Override\n\tpublic &lt;T&gt; void sort(T[] list, Comparator&lt;T&gt; comp) &#123;\n\t\tboolean swapped &#x3D; true;\n\t\tfor (int i &#x3D; 1, len &#x3D; list.length; i &lt; len &amp;&amp; swapped; ++i) &#123;\n\t\t\tswapped &#x3D; false;\n\t\t\tfor (int j &#x3D; 0; j &lt; len - i; ++j) &#123;\n\t\t\t\tif (comp.compare(list[j], list[j + 1]) &gt; 0) &#123;\n\t\t\t\t\tT temp &#x3D; list[j];\n\t\t\t\t\tlist[j] &#x3D; list[j + 1];\n\t\t\t\t\tlist[j + 1] &#x3D; temp;\n\t\t\t\t\tswapped &#x3D; true;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n\n95、用Java写一个折半查找\n\n\n\n\n\n\n\n\n折半查找，也称二分查找、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组已经为空，则表示找不到指定的元素。这种搜索算法每一次比较都使搜索范围缩小一半，其时间复杂度是O(logN)。\nimport java.util.Comparator;\n\npublic class MyUtil &#123;\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; int binarySearch(T[] x, T key) &#123;\n   return binarySearch(x, 0, x.length- 1, key);\n&#125;\n\n&#x2F;&#x2F; 使用循环实现的二分查找\npublic static &lt;T&gt; int binarySearch(T[] x, T key, Comparator&lt;T&gt; comp) &#123;\n   int low &#x3D; 0;\n   int high &#x3D; x.length - 1;\n   while (low &lt;&#x3D; high) &#123;\n       int mid &#x3D; (low + high) &gt;&gt;&gt; 1;\n       int cmp &#x3D; comp.compare(x[mid], key);\n       if (cmp &lt; 0) &#123;\n         low&#x3D; mid + 1;\n       &#125;\n       else if (cmp &gt; 0) &#123;\n         high&#x3D; mid - 1;\n       &#125;\n       else &#123;\n         return mid;\n       &#125;\n   &#125;\n   return -1;\n&#125;\n\n&#x2F;&#x2F; 使用递归实现的二分查找\nprivate static&lt;T extends Comparable&lt;T&gt;&gt; int binarySearch(T[] x, int low, int high, T key) &#123;\n   if(low &lt;&#x3D; high) &#123;\n     int mid &#x3D; low + ((high -low) &gt;&gt; 1);\n     if(key.compareTo(x[mid])&#x3D;&#x3D; 0) &#123;\n        return mid;\n     &#125;\n     else if(key.compareTo(x[mid])&lt; 0) &#123;\n        return binarySearch(x,low, mid - 1, key);\n     &#125;\n     else &#123;\n        return binarySearch(x,mid + 1, high, key);\n     &#125;\n   &#125;\n   return -1;\n&#125;\n&#125;\n","slug":"常见面试100题","date":"2022-12-22T02:10:33.000Z","categories_index":"","tags_index":"面试题","author_index":"余有光"},{"id":"261a575d522f8fa1209360b03cf8aa7f","title":"常见面试题集锦","content":"常见面试题集锦一、自我介绍1、简单介绍自己的姓名、年龄、学历、籍贯等基本信息；\n2、从事计算机行业时长，项目经历有哪些？\n3、重点介绍你最近的一个项目的情况\n\n\n\n\n\n\n\n\n\n切忌把时间间隔比较就久的项目说的很具体，会浪费时间，导致你最想表达的近期项目没有时间进行展示。\n二、项目情况类问题\n新增订单的流程？\n\n\n\n\n\n\n\n\n\n\n在用户已经登录的前提下，用户选好了商品,或勾选了购物车中购买的商品就可以进行订单的生成了；\n\n首先减少库存数,如果用户从购物车勾选,删除用户勾选购物车的对应商品；\n\n然后开始收集各种数据,使用Leaf生成唯一的id,通过查询获取单价和购买的数量,生成订单对象同时也生成订单项对象，一个订单中可能包含多个商品；然后我们计算总价,包含运费和优惠的处理\n\n所有数据收集完毕之后,新增到数据库\n\n我们利用Dubbo去修改sku库存信息,其他修改都是本模块的功能，如果任何数据库操作失败都要抛出异常\n\n我们可以利用分布式事务seata来根据运行状态决定最终要提交还是回滚保证订单生成之后数据的完整性\n\n\n\n说一下商品秒杀的流程？\n\n\n\n\n\n\n\n\n\n对于秒杀业务,我们首先要考虑的是怎么能够在有限的设备上达到最高的并发因为秒杀是典型的高并发高性能的业务需求所以我们要尽可能的使用能够提升性能和并发的组件或功能同时保证服务器的稳定运行例如:Redis、ES、Sentinel、消息队列等具体实现秒杀分为以下几个步骤：\n1、秒杀前准备我们可以利用任务调度工具Quartz在指定的时间进行缓存预热准备工作\n主要两方面：\n1.在秒杀开始前指定的时间,Redis缓存预热,将每个sku参与秒杀的库存数保存在Redis中；同时为了避免黄牛通过技术手段频繁访问，我们生成一个随机码,也保存在Redis中,用于验证是否为正常链接购买秒杀商品。\n2.在每个批次秒杀开始前,将本批次所有秒杀商品的spuid保存在布隆过滤器中,减少缓存穿透的情况\n2、秒杀信息的查询秒杀开始，用户在秒杀商品的规定时间内可以查询秒杀商品详情；所有秒杀商品spu查询时，都先查询布隆过滤器是否包含这个spuId，如果包含允许访问，如果不包含抛出异常，也要考虑布隆过滤器误判的情况，每当业务中查询spu和sku时，都需要先检查redis中是否包含这个数据，如果包含直接从redis中获得，如果不包含再从数据库中查，但是同时也注意，查询完了要保存到Redis中，以便之后的查询直接从redis中获取，在保存到Redis时，为了减少缓存雪崩的几率，我们为每个Spu和Sku对象都添加了过期时间随机数；查询返回前可以在判断一下当前时间是否在可秒杀该商品的时间段内，如果不在秒杀时间段内，抛出异常；只有返回了完整信息。前端才可能获得包含随机码的提交路径，否则是无法完成正常连接购买的。\n3、提交秒杀信息在用户购买秒杀商品时,保证用户登录的前提下\n验证用户是否重复秒杀(业务要求秒杀相同商品只能购买一次),我们使用userId和skuId,向Redis中保存一个key,如果没有这个key就是用户没有秒杀过,否则发生异常提示\n我们要保证用户购买时,这个商品有库存,减少库存后,获得剩余库存信息\n只要剩余库存不小于0,就可以为当前用户生成订单,否则发生异常\n生成订单直接Dubbo调用Order模块编写的生成订单的方法即可\n订单提交后,还需要修改秒杀sku库存数和生成秒杀成功记录保存在数据库\n但是这个业务非迫切运行,我们可以将信息发送给消息队列,削峰填谷\n然后再编写接收消息队列的代码,完成修改秒杀库存和生成秒杀成功记录的操作\n在控制层方法上添加注解实现Sentinel的限流,保证这个业务在非常大的并发下,也能稳定运行\n控制器方法中还要判断用户请求路径中的随机码,是否和Redis中保存的随机码一致,防止非正常链接购买\n\n说一下spring  security单点登录的流程。\n\n\n\n\n\n\n\n\n\n\n用户在登录页面中提交表单信息，把包含username和password的信息提交给服务器。\n服务器实现UserDetailsService接口 -&gt; 在UserDetailsServiceImpl中重写loadByUsername()方法，将username作为参数，并查询数据库中的username信息，并自动比对密码。第一次登录会生成JWT信息返回给客户端，下一次再访问的时候，需要将JWT信息配置在请求头中作为登录凭证。\n服务器后台过滤器接收到请求，我们判断他是否包含了符合要求的JWT信息，获取他请求头中Authorization属性中的值。如果JWT无效我们直接放行；\n如果有效，我们添加JWT信息解析，然后将解析得到的数据，自定义当前登录当事人LoginPrincipal，其中包含userId、username。\n通过实例化UsernamePasswordAuthenticationToken(userId,null,LoginPrincipal)，得到了创建Authentication认证信息。\n将创建的认证信息Authentication保存到SecurityContext中，然后放行。\n在SecurityConfiguration配置中自定义JWT过滤器，将我们自定义的过滤器添加在Spring Security框架内置的过滤器之前。\n控制器中通过注解参数@AuthenticationPrincipal LoginPrincipal loginPrincipal 进行当事人属性的传递。\n通过配置关闭预检功能。\n\n\n三级分类树是怎么实现的，业务流程有哪些？\n\n\n\n\n\n\n\n\n\n本项目使用固定的三级分类树是自关联分类(所有分类信息在一张表中)\n实现思路 ： \n1.一次性查询出所有分类对象(List集合)\n2.遍历集合将当前分类对象以父分类id为Key,以当前对象作为值,保存在一个Map中,这个Map对象的Key(父级分类ID)对应的value,会包含它的所有子分类对象\n3.遍历所有分类对象,以当前分类对象id为key,从Map中获取它的子分类,关联到三级分类树对象中,最后返回包含三级分类树结构的集合\n4.查询返回之前,将三级分类树保存到Redis,以便以后的请求高效获取\n\n消息队列用的是什么技术？如何用消息队列生成秒杀订单信息记录？\n\n\n三、JAVA技术类问题\n设计模式有了解过吗？谈谈你了解的设计模式。\n\n\n\n\n\n\n\n\n\n\n创建型模式：共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式结构型模式：共7种：适配器模式、装饰器模式、代理模式、桥接模式、外观模式、组合模式、享元模式行为型模式：共11种：策略模式、模板方法模式、观察者模式、责任链模式、访问者模式、中介者模式、迭代器模式、命令模式、状态模式、备忘录模式、解释器模式\n常用的模式：单例模式、工厂模式、代理模式等等。\n\nArray 和ArrayList有什么区别？使用时需要注意什么？\n\n\n\n\n\n\n\n\n\n\nArray可以包含基本类型和对象类型，ArrayList只能包含对象类型。Array大小是固定的，ArrayList的大小是动态变化的。ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。ArrayList可以算是Array的加强版，（对array有所取舍的加强）。 \n如果我们需要对元素进行频繁的移动或删除，或者是处理的是超大量的数据，那么，使用ArrayList就真的不是一个好的选择，因为它的效率很低，使用数组进行这样的动作就很麻烦，那么，可以考虑选择LinkedList。\n\n单例模式如何实现的？\n\n\n\n\n\n\n\n\n\n\n2.1. 定义：单例模式是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。\n2.2.该模式有三个基本要点：\n\n一是这个类只能有一个实例；\n二是它必须自行创建这个实例；\n三是它必须自行向整个系统提供这个实例。\n\n2.3.应用场景：J2EE中的ServlertContext、SerletContextConfig等、Spring框架应用中的ApplicationContext、数据库连接池等。\n2.4.实现单例模式：\n\n饿汉式单例模式  \n\n适用于单例模式较少的场景如果我们在程序启动后，一定会加载到类，那么用饿汉模式实现的单例简单又实用；如果我们是写一些工具类，则优先考虑使用懒汉模式，可以避免提前被加载到内存中，占用系统资源。\n\n懒汉式单例模式（双重检查锁）   \n\n\n\n\n\n\n\n\n\n如果我们在程序启动后，一定会加载到类，那么用饿汉模式实现的单例简单又实用；如果我们是写一些工具类，则优先考虑使用懒汉模式，可以避免提前被加载到内存中，占用系统资源。\n\n静态内部类实现单例模式\n\n\n\n\n\n\n\n\n\n屏蔽饿汉式单例模式的内存浪费问题和双重检查锁中synchronized的性能问题，同时考虑避免因为反射破坏单例问题。\n相对而言性能最好！\n\n注册式单例模式\n\n枚举式单例模式     —–Effective Java推荐单例模式\n容器式单例模式     —–适用于实例非常多的情况，便于管理，但是是非线程安全的\n\n\n\n\n\n什么是观察者模式？\n\n\n\n\n\n\n\n\n\n\n\n\n说一下异常有哪些大类？分别有什么区别？\n\n  \n\n异常Throwable分为两个重要的子类：\n​        1、Error （错误），这一类通常是系统级别的错误，也是程序无法处理的错误，通常是Java虚拟机出现问题才会报出Error类型的错误，\n​        2、Exception（异常），这一类表示程序本身可以处理的异常。有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ClassNoFoundException）和 ArrayIndexOutOfBoundException。\n​        3、异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。\n\nmybatis框架的优缺点？\n\n数据库链接池了解吗？你知道哪些数据库链接池?\n\nmysql数据库有哪些类型？比如文本类型有哪些？整数类型有哪些？小数类型有哪些？\n\n\n\n\n\n\n\n\n\n文本类型：char、varchar\n整数类型：tinyInt、smallInt、mediumint、int。\n小数类型：float、double、decimal\n\nmysql数据库文本类型char和varchar的区别是什么？\n\n\n\n\n\n\n\n\n\n\n\n表示的范围不同，\nchar的能表示0~255个字节，且char是定长的，不足的部分用隐藏的空格填充；\nvarchar能表示0~65535个字节，且不是定长的。\n\nmysql数据库的引擎有哪些？区别是什么？\n\n\n\n\n\n\n\n\n\n\nInnodb引擎：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标                        就是处理大数据容量的数据库系统。MyIASM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。\n  \n\n\n数据库索引有哪些？\n\n\n\n\n\n\n\n\n\n\nInnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做覆盖索引会非常高效。\n数据库自带性能分析命令是：explain 命令 + 查询命令\n生成索引常用命令：ALTER TABLE table_name ADD INDEX index_name (column_list);\n​                                CREATE INDEX index_name ON table_name (column_list);\n\n面向对象三大特征？\n\n\n\n\n\n\n\n\n\n封装、继承、多态\n封装：对实体的属性和功能进行访问控制，向信任的实体开放，对不信任的实体隐藏。\n继承：使得低层级的类可以延用高层级类的特征和方法。\n多态：同一个实体同时具有多种形式。同字面意思，及一个对象在不同的情况下会有不同的体现。\n\nSpring？Spring Boot的区别。\n\n\n\n\n\n\n\n\n\n\nSpring是Spring软件全家桶的基石，提供了企业软件的各种基础组件，可以使开发更加专注在业务功能上，其核心功能有IOC /DI 控制反转、依赖注入，以及面向切面编程AOP。\nSpring Boot是以Spring为基础，帮助快速搭建Spring应用程序，开箱即用，几乎不用配置，并且提供了以来管理，可以用很少的代码整合各种资源包括JDBC、MyBatis等等。Spring Boot提供了打包工具，可将应用打包成为一个Fat jar ，然后一个命令就可以启动。\n\n\nfinal、finnally、finalize 的区别是什么？\n\n\n\n\n\n\n\n\n\nfinal 表示不可修改的，可以用来修饰类，方法，变量。\nfinal修饰class表示该class不可以被继承。final修饰方法表示方法不可以被overrride（重写）。final修饰变量表示变量是不可以修改。一般来说推荐将本地变量，成员变量，固定的静态变量用final修饰，明确是不可以被修改的。\nfinally是Java的异常处理机制中的一部分。finally块的作用就是为了保证无论出现什么情况，finally块里的代码一定会被执行。\n一般来说在try-catch-finally 来进行类似关闭 JDBC连接，释放锁等资源的操作。如果try语句块里有return语句，那么finally还会被执行吗？答案是肯定的。\nfinalize是Object类的一个方法，是GC进行垃圾回收前要调用的一个方法。\n如果实现了非空的这个方法，那么会导致相应对象回收呈现数量级上的变慢，在新版的JDK中（好像是1.9之后的版本），这个方法已经逐渐被抛弃了。\n\n面向对象的七大设计原则\n\nSpring MVC 的处理流程是什么？\n\n\n\n\n\n\n\n\n\n\n用户发送请求至前端控制器DispatcherServlet\nDispatcherServlet收到请求调用处理器映射器HandlerMapping。\n处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理    器拦截器)一并返回给DispatcherServlet。\nDispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作\n执行处理器Handler(Controller，也叫页面控制器)。\nHandler执行完成返回ModelAndView\nHandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet\nDispatcherServlet将ModelAndView传给ViewReslover视图解析器\nViewReslover解析后返回具体View\nDispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。\nDispatcherServlet响应用户。\n\n\n缓存穿透，击穿，雪崩是什么？\n\n\n\n\n\n\n\n\n\n缓存穿透：一个业务请求先查询redis,redis没有这个数据,那么就去查询数据库,但是数据库也没有的情况\n缓存击穿：一个计划在Redis中保存的数据,通过业务查询,查询到的数据在Redis中没有,但是数据库中有的情况。\n\n缓存雪崩：指的就是Redis中保存的数据,短时间内有大量数据同时到期的情况。\n\nSQL调优有哪些方法？\n\nRedis缓存淘汰策略有哪些？\n\n线程的创建方式有哪些？\n\n说一下你了解的IO流\n\n\n\n\n\n\n\n\n\n节点流：可以从或向一个特定的地方（节点）读写数据，直接跟数据源相接。FileInputStream FileOutputStreanByteArrayInputStream ByteArrayOutputStream\n过滤流：是对一个已存在的流的的基础上进行功能扩展。BufferedImputStrean BufferedOutputStreamInputStreamReader OutputStreamWriterObjectInputStream ObjectOutputStream\n\n\n四、项目部署类问题\nSpring Boot里面用到maven了吗？\n\n你们项目部署到了哪里？\n\n项目部署在阿里云上的话，用到了哪些设备？\n\nDocker命令有了解吗？常用的命令有哪些？\n\n\n\n\n\n\n\n\n\n\n\nLinux系统中查询日志的命令是什么？\n\n\n\n1、查询日志尾部最后10行的日志;$ tail -n 10 test.log2、查询10行之后的所有日志;$ tail -n +10 test.log3、循环实时查看最后1000行记录(最常用的)$ tail -fn 1000 test.log\n4、如果一次性查询的数据量太大,可以进行翻页查看，例如:$ tail -n 4700 aa.log |more -1000 可以进行多屏显示(ctrl + f 或者 空格键可以快捷键)\n最常用的搜索关键字附近的日志命令：\ncat -n filename | grep “关键字”\n其他情况：\ncat app.log | grep -C 5 ‘关键字’ 　　(显示日志里匹配字串那行以及前后5行)\ncat app.log | grep -B 5 ‘关键字’ 　　(显示匹配字串及前5行)\ncat app.log | grep -A 5 ‘关键字’ 　　(显示匹配字串及后5行)\n","slug":"常见面试题集锦","date":"2022-12-07T15:44:12.000Z","categories_index":"","tags_index":"面试","author_index":"余有光"},{"id":"99d3803d2ba14375937b06e7a1f36b52","title":"单点登录","content":"单点登录\nSSO ：Single Sign On，即：单点登录\n单点登录表现为：在集群或分布式系统中，客户端在其中的某1个服务器登录，后续的请求被分配到其它服务器处理时，其它服务器也能识别用户的身份。\n单点登录的实现方案有：\n\n\n共享Session\n把所有客户端的Session数据存储到专门的服务器上，其它任何服务器需要识别客户端身份时，都从这个专门的服务器上去查找、读取Session数据\n缺点：Session的有效期不宜过长\n优点：编码简单，读取Session数据基本上没有额外牺牲性能\n\n\nToken\n当某客户端登录成功，服务器端将响应Token到客户端，在后续的访问中，客户端自行携带Token数据来访问任何服务器，且任何服务器都具备解析此Token的功能，即可识别客户端的身份\nJWT（JSON Web Token）也是Token的一种\n缺点：编写代码略难，需要频繁解析JWT，需要牺牲一部分性能来进行解析\n优点：可以长时间有效\n\n\n\n如何实现SSO目前，在csmall-passport项目中已经现实了认证与授权，只要客户端能携带有效的JWT，则服务器端可以识别客户端的身份！\n在csmall-product项目中，只需要添加Spring Security框架的依赖项，并添加认证相关代码，就可以实现“客户端在csmall-passport登录后，在csmall-product上也可以识别用户的身份”！\n需要从csmall-passport中复制到csmall-product中的代码有：\n\n复制相关依赖项\n\nspring-boot-starter-security\njjwt\nfastjson\n\n\n复制application-dev.yml中关于JWT的自定义配置\n\nLoginPrincipal\n\nServiceCode（更新文件，在passport中添加了一些新的业务状态码，在product中也将需要使用到）\n\nJwtAuthorizationFilter\n\nSecurityConfiguration\n\n\n删除PasswordEncoder的@Bean方法\n删除AuthenticationManager的@Bean方法\n删除configurer()方法中“白名单”中的 &quot;/admins/login&quot; 路径\n\n\nGlobalExceptionHandler（更新文件，处理“无操作权限”相关异常）\n\n\n在前端项目中，保证除了登录的每个请求都添加了请求头中的JWT即可。\n本项目基于Spring Security和JWT实现了SSO（单点登录）。\n流程总结：\n用户在登录页面中提交表单信息，把包含username和password的信息提交给服务器。\n服务器实现UserDetailsService接口 -&gt; 在UserDetailsServiceImpl中重写loadByUsername()方法，将username作为参数，并查询数据库中的username信息，并自动比对密码。第一次登录会生成JWT信息返回给客户端，下一次再访问的时候，需要将JWT信息配置在请求头中作为登录凭证。\n服务器后台过滤器接收到请求，我们判断他是否包含了符合要求的JWT信息，获取他请求头中Authorization属性中的值。如果JWT无效我们直接放行；\n如果有效，我们添加JWT信息解析，然后将解析得到的数据，自定义当前登录当事人LoginPrincipal，其中包含userId、username。\n通过实例化UsernamePasswordAuthenticationToken(userId,null,LoginPrincipal)，得到了创建Authentication认证信息。\n将创建的认证信息Authentication保存到SecurityContext中，然后放行。\n在SecurityConfiguration配置中自定义JWT过滤器，将我们自定义的过滤器添加在Spring Security框架内置的过滤器之前。\n控制器中通过注解参数@AuthenticationPrincipal LoginPrincipal loginPrincipal 进行当事人属性的传递。\n通过配置关闭预检功能。\n\n","slug":"单点登录","date":"2022-12-06T15:30:00.000Z","categories_index":"","tags_index":"必会技能","author_index":"余有光"},{"id":"82381b80c937780767578a231f4c2205","title":"常用软件下载与安装使用","content":"一、Nacos1、Nacos 下载https://github.com/alibaba/nacos/releases/download/1.4.3/nacos-server-1.4.3.zip\n2、安装启动Nacos\n我们下载了Nacos软件\n将压缩包解压(注意不要有中文路径或空格)\n​    \n打开解压得到的文件夹后打卡bin目录会有如下内容\n\nstartup.cmd是windows系统启动Nacos的命令\nshutdown.cmd是windows系统停止Nacos的命令\n\n\n\n\n\n\n\n\n\n.sh结尾的文件是linux和mac系统的启动和停止文件\n启动Nacos不能直接双击startup.cmd\n\n\n而需要打开dos窗口来执行\nWin+R输入cmd\n\n\n启动命令中 standalone是表示本次启动以单机模式运行\n如果不指定会默认以集群模式运行,无法完成功能\nstartup.cmd -m standalone\n\n如果运行成功会显示8848端口\n打开浏览器输入地址\nhttp://localhost:8848/nacos\n\n如果首次访问没有响应,可以尝试从新解压和运行,再访问\n登录系统\n用户名密码都是nacos\n进入后会看到列表后台\n注意不要关闭doc窗口,一旦关闭,nacos就停止了\n二、Seata1、下载Seatahttps://github.com/seata/seata/releases\nhttps://github.com/seata/seata/releases/download/v1.4.2/seata-server-1.4.2.zip\n2、启动Seata\n\n启动所有4个服务\n运行knife4j测试\n测试business模块,如果能够运行出现成功或出现异常的提示信息\n并在数据库中呈现正常运行或回滚的效果,表示一切正常\n在windows系统中运行seata可能出现不稳定的情况,重启seata即可解决\n三、Sentinel1、Sentinel下载地址https://github.com/alibaba/Sentinel/releases\n可以直接运行发送给大家的bat文件\n\n\n2、Sentinel启动复制Sentinel到硬盘,然后直接双击start-sentinel.bat即可\n四、Redis1、Redis下载doc.canglaoshi.org\n\n2、Redis的解压安装和运行将我们下载的压缩包解压后,得到内容如图\n\nredis-server.exe\\redis-start.bat这两个文件双击其中任何一个都可以达到启动Redis的效果\n但是这个打开的界面一旦关闭Redis就停止了\n上面的启动方式每次开机都要运行,而且打开的窗口如果不小心关掉了Redis就停止了\n比较麻烦,我们希望Redis能够像mysql一样,每次开机自动启动\n\nservice-installing.bat        双击能够将Redis进行安装,到当前系统中\n\nservice-start.bat               双击能够启动当前Redis的服务,默认每次开机                    \n​                                            自动启动\n\nservice-stop.bat                停止服务\n\nservice-uninstalling.bat   卸载程序\n\n\n我们只需要运行1,2两个文件\n就可以实现每次开机自动启动Redis的效果\n我们可以启动redis-cli.exe进行测试  \nRedis默认端口号:6379\n测试方法,在redis-cli.exe运行的窗口中输入指令”info”\n观察输出结果\n五、Elasticsearch1、Elasticsearch软件下载doc.canglaoshi.org\n\n2、Elasticsearch的启动官方下载链接\nhttps://www.elastic.co/cn/downloads/past-releases#elasticsearch\n将下载的280兆的压缩包解压\n进入压缩包后得到如下bin目录中的内容\n\n双击运行elasticsearch.bat文件,可以启动ES\n\ndos窗口不能关,一关ES就停止工作了\nES没有支持开机自动启动的功能,所以每次开机需要ES时只能手动启动\n怎么证明我们的ES正常工作呢\n可以打开浏览器输入地址\nlocalhost:9200\n\nmac系统启动\ntar -xvf elasticsearch-7.6.2-darwin-x86_64.tar.gz \ncd elasticsearch-7.6.2&#x2F;bin \n.&#x2F;elasticsearch\n\nlinux:\ntar -xvf elasticsearch-7.6.2-linux-x86_64.tar.gz\ncd elasticsearch-7.6.2&#x2F;bin\n.&#x2F;elasticsearch\n\n","slug":"my-first-blog","date":"2022-12-04T04:59:50.000Z","categories_index":"","tags_index":"软件安装及使用","author_index":"余有光"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-12-04T04:23:08.190Z","categories_index":"","tags_index":"","author_index":"余有光"}]