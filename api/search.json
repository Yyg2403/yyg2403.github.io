[{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"关于Spring Security框架Spring Security主要解决了认证与授权的相关问题。\n\n\nSpring Security的基础依赖项是spring-security-core，在Spring Boot项目中，通常添加spring-boot-starter-security这个依赖项，它包含了spring-security-core，并且，还自动执行了一系列配置！默认的配置效果有：\n\n所有请求都是必须通过认证的\n\n  如果未认证，同步请求将自动跳转到 /login，是框架自带的登录页，非跨域的异步请求将响应 403 错误\n\n\n提供了默认的登录信息，用户名为\n  user\n\n  ，密码是启动项目是随机生成的，在启动日志中可以看到\n\n  当登录成功后，会自动重定向到此前访问的URL\n  当登录成功后，可以执行所有同步请求，所有异步的POST请求都暂时不可用\n  可以通过 /logout 退出登录\n\n\n\n59. 关于BCrypt算法当添加了Spring Security相关的依赖项后，此依赖项中将包含BCryptPasswordEncoder工具类，是一个使用BCrypt算法的密码编码器，它实现了PasswordEncoder接口，并重写了接口中的String encode(String rawPassword)方法，用于对密码原文进行编码（加密），及重写了boolean matches(String rawPassword, String encodedPassword)方法，用于验证密码原文与密文是否对应。\nBCrypt算法会自动使用随机的盐值进行加密处理，所以，当反复对同一个原文进行加密处理，每次得到的密文都是不同的，但这并不影响验证密码！\nBCrypt算法被设计为是一种慢速运算的算法，可以一定程度上避免或缓解密码被暴力破解（使用循环进行穷举的破解）。\n60. 关于Spring Security的基本配置package cn.tedu.csmall.passport.config;\n​\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\n​\n@Slf4j\n@Configuration\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123;\n​\n    &#x2F;&#x2F; @Bean\n    public PasswordEncoder passwordEncoder() &#123;\n        log.debug(&quot;创建@Bean方法定义的对象：PasswordEncoder&quot;);\n        return new BCryptPasswordEncoder();\n    &#125;\n​\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        &#x2F;&#x2F; 【配置白名单】\n        &#x2F;&#x2F; 在配置路径时，星号是通配符\n        &#x2F;&#x2F; 1个星号只能匹配任何文件夹或文件的名称，但不能跨多个层级\n        &#x2F;&#x2F; 例如：&#x2F;*&#x2F;test.js，可以匹配到 &#x2F;a&#x2F;test.js 和 &#x2F;b&#x2F;test.js，但不可以匹配到 &#x2F;a&#x2F;b&#x2F;test.js\n        &#x2F;&#x2F; 2个连续的星号可以匹配若干个文件夹的层级\n        &#x2F;&#x2F; 例如：&#x2F;**&#x2F;test.js，可以匹配 &#x2F;a&#x2F;test.js 和 &#x2F;b&#x2F;test.js 和 &#x2F;a&#x2F;b&#x2F;test.js\n        String[] urls &#x3D; &#123;\n                &quot;&#x2F;doc.html&quot;,\n                &quot;&#x2F;**&#x2F;*.js&quot;,\n                &quot;&#x2F;**&#x2F;*.css&quot;,\n                &quot;&#x2F;swagger-resources&quot;,\n                &quot;&#x2F;v2&#x2F;api-docs&quot;\n        &#125;;\n​\n        http.csrf().disable(); &#x2F;&#x2F; 禁用CSRF（防止伪造的跨域攻击）\n​\n        http.authorizeRequests() &#x2F;&#x2F; 对请求执行认证与授权\n                .antMatchers(urls) &#x2F;&#x2F; 匹配某些请求路径\n                .permitAll() &#x2F;&#x2F; （对此前匹配的请求路径）不需要通过认证即允许访问\n                .anyRequest() &#x2F;&#x2F; 除以上配置过的请求路径以外的所有请求路径\n                .authenticated(); &#x2F;&#x2F; 要求是已经通过认证的\n​\n        http.formLogin(); &#x2F;&#x2F; 开启表单验证，即视为未通过认证时，将重定向到登录表单，如果无此配置，则直接响应403\n    &#125;\n​\n&#125;\n\n61. 关于登录的账号默认情况下，Spring Security使用user作为用户名，使用随机的UUID作为密码来登录！如果需要自行指定登录账号，需要自定义一个组件类，实现UserDetailsService接口，此接口中定义了UserDetails loadUserByUsername(String username)，在处理认证时，当用户（使用者）输入了用户名、密码并提交，Spring Security就会自动使用用户在表单中输入的用户名来调用loadUserByUsername()方法，作为开发者，应该重写此方法，并根据用户名来返回匹配的UserDetails对象，此对象中应该包含用户的相关信息，例如密码等，当Spring Security得到调用loadUserByUsername()返回的UserDetails对象后，会自动处理后续的认证过程，例如验证密码是否匹配等。\n例如，在根包下创建security.UserDetailsServiceImpl类：\npackage cn.tedu.csmall.passport.security;\n​\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.security.core.userdetails.User;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n​\n@Slf4j\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService &#123;\n​\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123;\n        log.debug(&quot;Spring Security调用了loadUserByUsername()方法，参数：&#123;&#125;&quot;, s);\n        // 暂时使用模拟数据来处理登录认证，假设正确的用户名和密码分别是root和123456\n        if (&quot;root&quot;.equals(s)) &#123;\n            UserDetails userDetails = User.builder()\n                    .username(&quot;root&quot;)\n                    .password(&quot;123456&quot;)\n                    .accountExpired(false)\n                    .accountLocked(false)\n                    .disabled(false)\n                    .authorities(&quot;这是一个山寨的权限标识&quot;) // 权限，注意，此方法的参数不可以为null，在不处理权限之前，可以写一个随意的字符串值\n                    .build();\n            log.debug(&quot;即将向Spring Security返回UserDetails对象：&#123;&#125;&quot;, userDetails);\n            return userDetails;\n        &#125;\n        log.debug(&quot;此用户名【&#123;&#125;】不存在，即将向Spring Security返回为null的UserDetails值&quot;, s);\n        return null;\n    &#125;\n​\n&#125;\n\n另外，Spring Security在执行认证时，需要使用到密码编码器（PasswordEncoder），则在SecurityConfiguration配置类中添加：\n@Bean\npublic PasswordEncoder passwordEncoder() &#123;\n    log.debug(&quot;创建@Bean方法定义的对象：PasswordEncoder&quot;);\n    return NoOpPasswordEncoder.getInstance(); &#x2F;&#x2F; 无操作的密码编码器，即：不会执行加密处理\n&#125;\n\n提示：一旦启动项目时，Spring Security从Spring容器中找到了UserDetailsService接口类型的对象，则默认的用户名和随机的密码都不会再使用（启动项目中也不会再看到随机的临时密码）。\n","slug":"基于JWT实现单点登录功能","date":"2022-12-06T10:43:32.568Z","categories_index":"","tags_index":"","author_index":"余有光"},{"id":"3f881ad613b08b9c0142f2498d10970b","title":"post_name","content":"","slug":"post-name-1","date":"2022-12-04T09:52:11.000Z","categories_index":"","tags_index":"","author_index":"余有光"},{"id":"3f881ad613b08b9c0142f2498d10970b","title":"post_name","content":"","slug":"post-name","date":"2022-12-04T09:51:07.000Z","categories_index":"","tags_index":"","author_index":"余有光"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post.\n\n\n\n Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"my-second-blog","date":"2022-12-04T05:26:32.163Z","categories_index":"","tags_index":"","author_index":"余有光"},{"id":"82381b80c937780767578a231f4c2205","title":"常用软件下载与安装使用","content":"一、Nacos1、Nacos 下载https://github.com/alibaba/nacos/releases/download/1.4.3/nacos-server-1.4.3.zip\n2、安装启动Nacos\n我们下载了Nacos软件\n将压缩包解压(注意不要有中文路径或空格)\n​    \n打开解压得到的文件夹后打卡bin目录会有如下内容\n\nstartup.cmd是windows系统启动Nacos的命令\nshutdown.cmd是windows系统停止Nacos的命令\n\n\n\n\n\n\n\n\n\n.sh结尾的文件是linux和mac系统的启动和停止文件\n启动Nacos不能直接双击startup.cmd\n\n\n而需要打开dos窗口来执行\nWin+R输入cmd\n\n\n启动命令中 standalone是表示本次启动以单机模式运行\n如果不指定会默认以集群模式运行,无法完成功能\nstartup.cmd -m standalone\n\n如果运行成功会显示8848端口\n打开浏览器输入地址\nhttp://localhost:8848/nacos\n\n如果首次访问没有响应,可以尝试从新解压和运行,再访问\n登录系统\n用户名密码都是nacos\n进入后会看到列表后台\n注意不要关闭doc窗口,一旦关闭,nacos就停止了\n二、Seata1、下载Seatahttps://github.com/seata/seata/releases\nhttps://github.com/seata/seata/releases/download/v1.4.2/seata-server-1.4.2.zip\n2、启动Seata\n\n启动所有4个服务\n运行knife4j测试\n测试business模块,如果能够运行出现成功或出现异常的提示信息\n并在数据库中呈现正常运行或回滚的效果,表示一切正常\n在windows系统中运行seata可能出现不稳定的情况,重启seata即可解决\n三、Sentinel1、Sentinel下载地址https://github.com/alibaba/Sentinel/releases\n可以直接运行发送给大家的bat文件\n\n\n2、Sentinel启动复制Sentinel到硬盘,然后直接双击start-sentinel.bat即可\n四、Redis1、Redis下载doc.canglaoshi.org\n\n2、Redis的解压安装和运行将我们下载的压缩包解压后,得到内容如图\n\nredis-server.exe\\redis-start.bat这两个文件双击其中任何一个都可以达到启动Redis的效果\n但是这个打开的界面一旦关闭Redis就停止了\n上面的启动方式每次开机都要运行,而且打开的窗口如果不小心关掉了Redis就停止了\n比较麻烦,我们希望Redis能够像mysql一样,每次开机自动启动\n\nservice-installing.bat        双击能够将Redis进行安装,到当前系统中\n\nservice-start.bat               双击能够启动当前Redis的服务,默认每次开机                    \n​                                            自动启动\n\nservice-stop.bat                停止服务\n\nservice-uninstalling.bat   卸载程序\n\n\n我们只需要运行1,2两个文件\n就可以实现每次开机自动启动Redis的效果\n我们可以启动redis-cli.exe进行测试  \nRedis默认端口号:6379\n测试方法,在redis-cli.exe运行的窗口中输入指令”info”\n观察输出结果\n五、Elasticsearch1、Elasticsearch软件下载doc.canglaoshi.org\n\n2、Elasticsearch的启动官方下载链接\nhttps://www.elastic.co/cn/downloads/past-releases#elasticsearch\n将下载的280兆的压缩包解压\n进入压缩包后得到如下bin目录中的内容\n\n双击运行elasticsearch.bat文件,可以启动ES\n\ndos窗口不能关,一关ES就停止工作了\nES没有支持开机自动启动的功能,所以每次开机需要ES时只能手动启动\n怎么证明我们的ES正常工作呢\n可以打开浏览器输入地址\nlocalhost:9200\n\nmac系统启动\ntar -xvf elasticsearch-7.6.2-darwin-x86_64.tar.gz \ncd elasticsearch-7.6.2&#x2F;bin \n.&#x2F;elasticsearch\n\nlinux:\ntar -xvf elasticsearch-7.6.2-linux-x86_64.tar.gz\ncd elasticsearch-7.6.2&#x2F;bin\n.&#x2F;elasticsearch\n\n","slug":"my-first-blog","date":"2022-12-04T04:59:50.000Z","categories_index":"","tags_index":"软件安装及使用","author_index":"余有光"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-12-04T04:23:08.190Z","categories_index":"","tags_index":"","author_index":"余有光"}]