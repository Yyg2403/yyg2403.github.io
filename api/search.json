[{"id":"261a575d522f8fa1209360b03cf8aa7f","title":"常见面试题集锦","content":"常见面试题集锦一、自我介绍1、简单介绍自己的姓名、年龄、学历、籍贯等基本信息；\n2、从事计算机行业时长，项目经历有哪些？\n3、重点介绍你最近的一个项目的情况\n\n\n\n\n\n\n\n\n\n切忌把时间间隔比较就久的项目说的很具体，会浪费时间，导致你最想表达的近期项目没有时间进行展示。\n二、项目情况类问题\n新增订单的流程？\n说一下商品秒杀的流程？\n说一下spring  security单点登录的流程。\n三级分类树是怎么实现的，业务流程有哪些？\n消息队列用的是什么技术？如何用消息队列生成秒杀订单信息记录？\n\n三、JAVA技术类问题\n设计模式有了解过吗？谈谈你了解的设计模式。\n\n\n\n\n\n\n\n\n\n\n有了解过的，\n\nArray 和ArrayList有什么区别？使用时需要注意什么？\n\n\n\n\n\n\n\n\n\n\nArray可以包含基本类型和对象类型，ArrayList只能包含对象类型。Array大小是固定的，ArrayList的大小是动态变化的。ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。ArrayList可以算是Array的加强版，（对array有所取舍的加强）。 \n如果我们需要对元素进行频繁的移动或删除，或者是处理的是超大量的数据，那么，使用ArrayList就真的不是一个好的选择，因为它的效率很低，使用数组进行这样的动作就很麻烦，那么，可以考虑选择LinkedList。\n\n单例模式如何实现的？\n\n\n\n\n\n\n\n\n\n\n2.1. 定义：单例模式是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。\n2.2.该模式有三个基本要点：\n\n一是这个类只能有一个实例；\n二是它必须自行创建这个实例；\n三是它必须自行向整个系统提供这个实例。\n\n2.3.应用场景：J2EE中的ServlertContext、SerletContextConfig等、Spring框架应用中的ApplicationContext、数据库连接池等。\n2.4.实现单例模式：\n\n饿汉式单例模式  \n\n适用于单例模式较少的场景如果我们在程序启动后，一定会加载到类，那么用饿汉模式实现的单例简单又实用；如果我们是写一些工具类，则优先考虑使用懒汉模式，可以避免提前被加载到内存中，占用系统资源。\n\n懒汉式单例模式（双重检查锁）   \n\n\n\n\n\n\n\n\n\n如果我们在程序启动后，一定会加载到类，那么用饿汉模式实现的单例简单又实用；如果我们是写一些工具类，则优先考虑使用懒汉模式，可以避免提前被加载到内存中，占用系统资源。\n\n静态内部类实现单例模式\n\n\n\n\n\n\n\n\n\n屏蔽饿汉式单例模式的内存浪费问题和双重检查锁中synchronized的性能问题，同时考虑避免因为反射破坏单例问题。\n相对而言性能最好！\n\n注册式单例模式\n\n枚举式单例模式     —–Effective Java推荐单例模式\n容器式单例模式     —–适用于实例非常多的情况，便于管理，但是是非线程安全的\n\n\n\n\n\n什么是观察者模式？\n\n\n\n\n\n\n\n\n\n\n\n\n说一下异常有哪些大类？分别有什么区别？\n\n  \n\n异常Throwable分为两个重要的子类：\n​        1、Error （错误），这一类通常是系统级别的错误，也是程序无法处理的错误，通常是Java虚拟机出现问题才会报出Error类型的错误，\n​        2、Exception（异常），这一类表示程序本身可以处理的异常。有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ClassNoFoundException）和 ArrayIndexOutOfBoundException。\n​        3、异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。\n\nmybatis框架的优缺点？\n\n数据库链接池了解吗？你知道哪些数据库链接池?\n\nmysql数据库有哪些类型？比如文本类型有哪些？整数类型有哪些？小数类型有哪些？\n\nmysql数据库文本类型char和varchar的区别是什么？\n\n\n\n\n\n\n\n\n\n\n\n表示的范围不同，\nchar的能表示0~255个字节，且char是定长的，不足的部分用隐藏的空格填充；\nvarchar能表示0~65535个字节，且不是定长的。\n\nmysql数据库的引擎有哪些？区别是什么？\n\n\n\n\n\n\n\n\n\n\nInnodb引擎：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标                        就是处理大数据容量的数据库系统。MyIASM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。\n  \n\n\n数据库索引有哪些？\n\n\n\n\n\n\n\n\n\n\nInnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做覆盖索引会非常高效。\n数据库自带性能分析命令是：explain 命令 + 查询命令\n生成索引常用命令：ALTER TABLE table_name ADD INDEX index_name (column_list);\n​                                CREATE INDEX index_name ON table_name (column_list);\n\n面向对象三大特征？\n\n\n\n\n\n\n\n\n\n封装、继承、多态\n封装：对实体的属性和功能进行访问控制，向信任的实体开放，对不信任的实体隐藏。\n继承：使得低层级的类可以延用高层级类的特征和方法。\n多态：同一个实体同时具有多种形式。同字面意思，及一个对象在不同的情况下会有不同的体现。\n\n什么是spring？\n\nfinal、finnally、finalize 的区别是什么？\n\n\n\n\n\n\n\n\n\nfinal 表示不可修改的，可以用来修饰类，方法，变量。\nfinal修饰class表示该class不可以被继承。final修饰方法表示方法不可以被overrride（重写）。final修饰变量表示变量是不可以修改。一般来说推荐将本地变量，成员变量，固定的静态变量用final修饰，明确是不可以被修改的。\nfinally是Java的异常处理机制中的一部分。finally块的作用就是为了保证无论出现什么情况，finally块里的代码一定会被执行。\n一般来说在try-catch-finally 来进行类似关闭 JDBC连接，释放锁等资源的操作。如果try语句块里有return语句，那么finally还会被执行吗？答案是肯定的。\nfinalize是Object类的一个方法，是GC进行垃圾回收前要调用的一个方法。\n如果实现了非空的这个方法，那么会导致相应对象回收呈现数量级上的变慢，在新版的JDK中（好像是1.9之后的版本），这个方法已经逐渐被抛弃了。\n\n面向对象的七大设计原则\n\n缓存穿透，击穿，雪崩是什么？\n\n\n\n\n\n\n\n\n\n缓存穿透：一个业务请求先查询redis,redis没有这个数据,那么就去查询数据库,但是数据库也没有的情况\n缓存击穿：一个计划在Redis中保存的数据,通过业务查询,查询到的数据在Redis中没有,但是数据库中有的情况。\n缓存雪崩：指的就是Redis中保存的数据,短时间内有大量数据同时到期的情况。\n\nSQL调优有哪些方法？\n\nRedis缓存淘汰策略有哪些？\n\n线程的创建方式有哪些？\n\n说一下你了解的IO流\n\n\n四、项目部署类问题\nSpring Boot里面用到maven了吗？\n\n你们项目部署到了哪里？\n\n项目部署在阿里云上的话，用到了哪些设备？\n\nDocker命令有了解吗？常用的命令有哪些？\n\nLinux系统中查询日志的命令是什么？\n\n\n\n\n\n\n\n\n\n\n\n1、查询日志尾部最后10行的日志;$ tail -n 10 test.log2、查询10行之后的所有日志;$ tail -n +10 test.log3、循环实时查看最后1000行记录(最常用的)$ tail -fn 1000 test.log\n4、如果一次性查询的数据量太大,可以进行翻页查看，例如:$ tail -n 4700 aa.log |more -1000 可以进行多屏显示(ctrl + f 或者 空格键可以快捷键)\n最常用的搜索关键字附近的日志命令：\ncat -n filename | grep “关键字”\n其他情况：\ncat app.log | grep -C 5 ‘关键字’ 　　(显示日志里匹配字串那行以及前后5行)\ncat app.log | grep -B 5 ‘关键字’ 　　(显示匹配字串及前5行)\ncat app.log | grep -A 5 ‘关键字’ 　　(显示匹配字串及后5行)\n其他更多关于Linux系统命令可以查询相关博主的文章如下：\n  []: www.baidu.com    “百度”\n\n\n\n","slug":"常见面试题集锦","date":"2022-12-07T15:44:12.000Z","categories_index":"","tags_index":"面试","author_index":"余有光"},{"id":"99d3803d2ba14375937b06e7a1f36b52","title":"单点登录","content":"单点登录\nSSO ：Single Sign On，即：单点登录\n单点登录表现为：在集群或分布式系统中，客户端在其中的某1个服务器登录，后续的请求被分配到其它服务器处理时，其它服务器也能识别用户的身份。\n单点登录的实现方案有：\n\n\n共享Session\n把所有客户端的Session数据存储到专门的服务器上，其它任何服务器需要识别客户端身份时，都从这个专门的服务器上去查找、读取Session数据\n缺点：Session的有效期不宜过长\n优点：编码简单，读取Session数据基本上没有额外牺牲性能\n\n\nToken\n当某客户端登录成功，服务器端将响应Token到客户端，在后续的访问中，客户端自行携带Token数据来访问任何服务器，且任何服务器都具备解析此Token的功能，即可识别客户端的身份\nJWT（JSON Web Token）也是Token的一种\n缺点：编写代码略难，需要频繁解析JWT，需要牺牲一部分性能来进行解析\n优点：可以长时间有效\n\n\n\n如何实现SSO目前，在csmall-passport项目中已经现实了认证与授权，只要客户端能携带有效的JWT，则服务器端可以识别客户端的身份！\n在csmall-product项目中，只需要添加Spring Security框架的依赖项，并添加认证相关代码，就可以实现“客户端在csmall-passport登录后，在csmall-product上也可以识别用户的身份”！\n需要从csmall-passport中复制到csmall-product中的代码有：\n\n复制相关依赖项\n\nspring-boot-starter-security\njjwt\nfastjson\n\n\n复制application-dev.yml中关于JWT的自定义配置\n\nLoginPrincipal\n\nServiceCode（更新文件，在passport中添加了一些新的业务状态码，在product中也将需要使用到）\n\nJwtAuthorizationFilter\n\nSecurityConfiguration\n\n\n删除PasswordEncoder的@Bean方法\n删除AuthenticationManager的@Bean方法\n删除configurer()方法中“白名单”中的 &quot;/admins/login&quot; 路径\n\n\nGlobalExceptionHandler（更新文件，处理“无操作权限”相关异常）\n\n\n在前端项目中，保证除了登录的每个请求都添加了请求头中的JWT即可。\n本项目基于Spring Security和JWT实现了SSO（单点登录）。\n流程总结：\n用户在登录页面中提交表单信息，把包含username和password的信息提交给服务器。\n服务器实现UserDetailsService接口 -&gt; 在UserDetailsServiceImpl中重写loadByUsername()方法，将username作为参数，并查询数据库中的username信息，并自动比对密码。第一次登录会生成JWT信息返回给客户端，下一次再访问的时候，需要将JWT信息配置在请求头中作为登录凭证。\n服务器后台过滤器接收到请求，我们判断他是否包含了符合要求的JWT信息，获取他请求头中Authorization属性中的值。如果JWT无效我们直接放行；\n如果有效，我们添加JWT信息解析，然后将解析得到的数据，自定义当前登录当事人LoginPrincipal，其中包含userId、username。\n通过实例化UsernamePasswordAuthenticationToken(userId,null,LoginPrincipal)，得到了创建Authentication认证信息。\n将创建的认证信息Authentication保存到SecurityContext中，然后放行。\n在SecurityConfiguration配置中自定义JWT过滤器，将我们自定义的过滤器添加在Spring Security框架内置的过滤器之前。\n控制器中通过注解参数@AuthenticationPrincipal LoginPrincipal loginPrincipal 进行当事人属性的传递。\n通过配置关闭预检功能。\n\n","slug":"单点登录","date":"2022-12-06T15:30:00.000Z","categories_index":"","tags_index":"必会技能","author_index":"余有光"},{"id":"82381b80c937780767578a231f4c2205","title":"常用软件下载与安装使用","content":"一、Nacos1、Nacos 下载https://github.com/alibaba/nacos/releases/download/1.4.3/nacos-server-1.4.3.zip\n2、安装启动Nacos\n我们下载了Nacos软件\n将压缩包解压(注意不要有中文路径或空格)\n​    \n打开解压得到的文件夹后打卡bin目录会有如下内容\n\nstartup.cmd是windows系统启动Nacos的命令\nshutdown.cmd是windows系统停止Nacos的命令\n\n\n\n\n\n\n\n\n\n.sh结尾的文件是linux和mac系统的启动和停止文件\n启动Nacos不能直接双击startup.cmd\n\n\n而需要打开dos窗口来执行\nWin+R输入cmd\n\n\n启动命令中 standalone是表示本次启动以单机模式运行\n如果不指定会默认以集群模式运行,无法完成功能\nstartup.cmd -m standalone\n\n如果运行成功会显示8848端口\n打开浏览器输入地址\nhttp://localhost:8848/nacos\n\n如果首次访问没有响应,可以尝试从新解压和运行,再访问\n登录系统\n用户名密码都是nacos\n进入后会看到列表后台\n注意不要关闭doc窗口,一旦关闭,nacos就停止了\n二、Seata1、下载Seatahttps://github.com/seata/seata/releases\nhttps://github.com/seata/seata/releases/download/v1.4.2/seata-server-1.4.2.zip\n2、启动Seata\n\n启动所有4个服务\n运行knife4j测试\n测试business模块,如果能够运行出现成功或出现异常的提示信息\n并在数据库中呈现正常运行或回滚的效果,表示一切正常\n在windows系统中运行seata可能出现不稳定的情况,重启seata即可解决\n三、Sentinel1、Sentinel下载地址https://github.com/alibaba/Sentinel/releases\n可以直接运行发送给大家的bat文件\n\n\n2、Sentinel启动复制Sentinel到硬盘,然后直接双击start-sentinel.bat即可\n四、Redis1、Redis下载doc.canglaoshi.org\n\n2、Redis的解压安装和运行将我们下载的压缩包解压后,得到内容如图\n\nredis-server.exe\\redis-start.bat这两个文件双击其中任何一个都可以达到启动Redis的效果\n但是这个打开的界面一旦关闭Redis就停止了\n上面的启动方式每次开机都要运行,而且打开的窗口如果不小心关掉了Redis就停止了\n比较麻烦,我们希望Redis能够像mysql一样,每次开机自动启动\n\nservice-installing.bat        双击能够将Redis进行安装,到当前系统中\n\nservice-start.bat               双击能够启动当前Redis的服务,默认每次开机                    \n​                                            自动启动\n\nservice-stop.bat                停止服务\n\nservice-uninstalling.bat   卸载程序\n\n\n我们只需要运行1,2两个文件\n就可以实现每次开机自动启动Redis的效果\n我们可以启动redis-cli.exe进行测试  \nRedis默认端口号:6379\n测试方法,在redis-cli.exe运行的窗口中输入指令”info”\n观察输出结果\n五、Elasticsearch1、Elasticsearch软件下载doc.canglaoshi.org\n\n2、Elasticsearch的启动官方下载链接\nhttps://www.elastic.co/cn/downloads/past-releases#elasticsearch\n将下载的280兆的压缩包解压\n进入压缩包后得到如下bin目录中的内容\n\n双击运行elasticsearch.bat文件,可以启动ES\n\ndos窗口不能关,一关ES就停止工作了\nES没有支持开机自动启动的功能,所以每次开机需要ES时只能手动启动\n怎么证明我们的ES正常工作呢\n可以打开浏览器输入地址\nlocalhost:9200\n\nmac系统启动\ntar -xvf elasticsearch-7.6.2-darwin-x86_64.tar.gz \ncd elasticsearch-7.6.2&#x2F;bin \n.&#x2F;elasticsearch\n\nlinux:\ntar -xvf elasticsearch-7.6.2-linux-x86_64.tar.gz\ncd elasticsearch-7.6.2&#x2F;bin\n.&#x2F;elasticsearch\n\n","slug":"my-first-blog","date":"2022-12-04T04:59:50.000Z","categories_index":"","tags_index":"软件安装及使用","author_index":"余有光"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-12-04T04:23:08.190Z","categories_index":"","tags_index":"","author_index":"余有光"}]