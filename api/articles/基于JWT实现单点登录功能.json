{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"基于JWT实现单点登录功能","date":"2022-12-06T10:43:32.568Z","updated":"2022-12-06T10:43:45.237Z","comments":true,"path":"api/articles/基于JWT实现单点登录功能.json","keywords":null,"cover":[],"content":"<h2 id=\"关于Spring-Security框架\"><a href=\"#关于Spring-Security框架\" class=\"headerlink\" title=\"关于Spring Security框架\"></a>关于Spring Security框架</h2><p>Spring Security主要解决了认证与授权的相关问题。</p>\n<p><img src=\"https://note.youdao.com/yws/res/31/WEBRESOURCE001b700f2d64b512b47703c682fb4183\" alt=\"image-20220505105822385.png\"></p>\n<p>Spring Security的基础依赖项是<code>spring-security-core</code>，在Spring Boot项目中，通常添加<code>spring-boot-starter-security</code>这个依赖项，它包含了<code>spring-security-core</code>，并且，还自动执行了一系列配置！默认的配置效果有：</p>\n<ul>\n<li><p>所有请求都是必须通过认证的</p>\n<ul>\n<li>  如果未认证，同步请求将自动跳转到 <code>/login</code>，是框架自带的登录页，非跨域的异步请求将响应 <code>403</code> 错误</li>\n</ul>\n</li>\n<li><p>提供了默认的登录信息，用户名为</p>\n  <pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">user</code></pre>\n\n<p>  ，密码是启动项目是随机生成的，在启动日志中可以看到</p>\n<ul>\n<li>  当登录成功后，会自动重定向到此前访问的URL</li>\n<li>  当登录成功后，可以执行所有同步请求，所有异步的POST请求都暂时不可用</li>\n<li>  可以通过 <code>/logout</code> 退出登录</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"59-关于BCrypt算法\"><a href=\"#59-关于BCrypt算法\" class=\"headerlink\" title=\"59. 关于BCrypt算法\"></a>59. 关于BCrypt算法</h2><p>当添加了Spring Security相关的依赖项后，此依赖项中将包含<code>BCryptPasswordEncoder</code>工具类，是一个使用<code>BCrypt</code>算法的密码编码器，它实现了<code>PasswordEncoder</code>接口，并重写了接口中的<code>String encode(String rawPassword)</code>方法，用于对密码原文进行编码（加密），及重写了<code>boolean matches(String rawPassword, String encodedPassword)</code>方法，用于验证密码原文与密文是否对应。</p>\n<p>BCrypt算法会自动使用随机的盐值进行加密处理，所以，当反复对同一个原文进行加密处理，每次得到的密文都是不同的，但这并不影响验证密码！</p>\n<p>BCrypt算法被设计为是一种慢速运算的算法，可以一定程度上避免或缓解密码被暴力破解（使用循环进行穷举的破解）。</p>\n<h2 id=\"60-关于Spring-Security的基本配置\"><a href=\"#60-关于Spring-Security的基本配置\" class=\"headerlink\" title=\"60. 关于Spring Security的基本配置\"></a>60. 关于Spring Security的基本配置</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package cn.tedu.csmall.passport.config;\n​\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\n​\n@Slf4j\n@Configuration\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123;\n​\n    &#x2F;&#x2F; @Bean\n    public PasswordEncoder passwordEncoder() &#123;\n        log.debug(&quot;创建@Bean方法定义的对象：PasswordEncoder&quot;);\n        return new BCryptPasswordEncoder();\n    &#125;\n​\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        &#x2F;&#x2F; 【配置白名单】\n        &#x2F;&#x2F; 在配置路径时，星号是通配符\n        &#x2F;&#x2F; 1个星号只能匹配任何文件夹或文件的名称，但不能跨多个层级\n        &#x2F;&#x2F; 例如：&#x2F;*&#x2F;test.js，可以匹配到 &#x2F;a&#x2F;test.js 和 &#x2F;b&#x2F;test.js，但不可以匹配到 &#x2F;a&#x2F;b&#x2F;test.js\n        &#x2F;&#x2F; 2个连续的星号可以匹配若干个文件夹的层级\n        &#x2F;&#x2F; 例如：&#x2F;**&#x2F;test.js，可以匹配 &#x2F;a&#x2F;test.js 和 &#x2F;b&#x2F;test.js 和 &#x2F;a&#x2F;b&#x2F;test.js\n        String[] urls &#x3D; &#123;\n                &quot;&#x2F;doc.html&quot;,\n                &quot;&#x2F;**&#x2F;*.js&quot;,\n                &quot;&#x2F;**&#x2F;*.css&quot;,\n                &quot;&#x2F;swagger-resources&quot;,\n                &quot;&#x2F;v2&#x2F;api-docs&quot;\n        &#125;;\n​\n        http.csrf().disable(); &#x2F;&#x2F; 禁用CSRF（防止伪造的跨域攻击）\n​\n        http.authorizeRequests() &#x2F;&#x2F; 对请求执行认证与授权\n                .antMatchers(urls) &#x2F;&#x2F; 匹配某些请求路径\n                .permitAll() &#x2F;&#x2F; （对此前匹配的请求路径）不需要通过认证即允许访问\n                .anyRequest() &#x2F;&#x2F; 除以上配置过的请求路径以外的所有请求路径\n                .authenticated(); &#x2F;&#x2F; 要求是已经通过认证的\n​\n        http.formLogin(); &#x2F;&#x2F; 开启表单验证，即视为未通过认证时，将重定向到登录表单，如果无此配置，则直接响应403\n    &#125;\n​\n&#125;</code></pre>\n\n<h2 id=\"61-关于登录的账号\"><a href=\"#61-关于登录的账号\" class=\"headerlink\" title=\"61. 关于登录的账号\"></a>61. 关于登录的账号</h2><p>默认情况下，Spring Security使用<code>user</code>作为用户名，使用随机的UUID作为密码来登录！如果需要自行指定登录账号，需要自定义一个组件类，实现<code>UserDetailsService</code>接口，此接口中定义了<code>UserDetails loadUserByUsername(String username)</code>，在处理认证时，当用户（使用者）输入了用户名、密码并提交，Spring Security就会自动使用用户在表单中输入的用户名来调用<code>loadUserByUsername()</code>方法，作为开发者，应该重写此方法，并根据用户名来返回匹配的<code>UserDetails</code>对象，此对象中应该包含用户的相关信息，例如密码等，当Spring Security得到调用<code>loadUserByUsername()</code>返回的<code>UserDetails</code>对象后，会自动处理后续的认证过程，例如验证密码是否匹配等。</p>\n<p>例如，在根包下创建<code>security.UserDetailsServiceImpl</code>类：</p>\n<pre><code>package cn.tedu.csmall.passport.security;\n​\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.security.core.userdetails.User;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n​\n@Slf4j\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService &#123;\n​\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123;\n        log.debug(&quot;Spring Security调用了loadUserByUsername()方法，参数：&#123;&#125;&quot;, s);\n        // 暂时使用模拟数据来处理登录认证，假设正确的用户名和密码分别是root和123456\n        if (&quot;root&quot;.equals(s)) &#123;\n            UserDetails userDetails = User.builder()\n                    .username(&quot;root&quot;)\n                    .password(&quot;123456&quot;)\n                    .accountExpired(false)\n                    .accountLocked(false)\n                    .disabled(false)\n                    .authorities(&quot;这是一个山寨的权限标识&quot;) // 权限，注意，此方法的参数不可以为null，在不处理权限之前，可以写一个随意的字符串值\n                    .build();\n            log.debug(&quot;即将向Spring Security返回UserDetails对象：&#123;&#125;&quot;, userDetails);\n            return userDetails;\n        &#125;\n        log.debug(&quot;此用户名【&#123;&#125;】不存在，即将向Spring Security返回为null的UserDetails值&quot;, s);\n        return null;\n    &#125;\n​\n&#125;\n</code></pre>\n<p>另外，Spring Security在执行认证时，需要使用到密码编码器（<code>PasswordEncoder</code>），则在<code>SecurityConfiguration</code>配置类中添加：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Bean\npublic PasswordEncoder passwordEncoder() &#123;\n    log.debug(&quot;创建@Bean方法定义的对象：PasswordEncoder&quot;);\n    return NoOpPasswordEncoder.getInstance(); &#x2F;&#x2F; 无操作的密码编码器，即：不会执行加密处理\n&#125;</code></pre>\n\n<p>提示：一旦启动项目时，Spring Security从Spring容器中找到了<code>UserDetailsService</code>接口类型的对象，则默认的用户名和随机的密码都不会再使用（启动项目中也不会再看到随机的临时密码）。</p>\n","feature":true,"text":"关于Spring Security框架Spring Security主要解决了认证与授权的相关问题。 Spring Security的基础依赖项是spring-security-core，在Spring Boot项目中，通常添加spring-boot-starter-securi...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8ESpring-Security%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">关于Spring Security框架</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#59-%E5%85%B3%E4%BA%8EBCrypt%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">59. 关于BCrypt算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#60-%E5%85%B3%E4%BA%8ESpring-Security%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">60. 关于Spring Security的基本配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#61-%E5%85%B3%E4%BA%8E%E7%99%BB%E5%BD%95%E7%9A%84%E8%B4%A6%E5%8F%B7\"><span class=\"toc-text\">61. 关于登录的账号</span></a></li></ol>","author":{"name":"余有光","slug":"blog-author","avatar":"https://note.youdao.com/s/VyTVfJGx","link":"/","description":"博主是个懒人，想起来更新博客就会写，取决于灵感来没来或者游戏肝完没有。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"post_name","uid":"3f881ad613b08b9c0142f2498d10970b","slug":"post-name-1","date":"2022-12-04T09:52:11.000Z","updated":"2022-12-04T09:52:11.586Z","comments":true,"path":"api/articles/post-name-1.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"余有光","slug":"blog-author","avatar":"https://note.youdao.com/s/VyTVfJGx","link":"/","description":"博主是个懒人，想起来更新博客就会写，取决于灵感来没来或者游戏肝完没有。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}